// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: items.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_items_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_items_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "links.pb.h"
#include "semiotic_classes.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_items_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_items_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[4]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_items_2eproto;
namespace speech {
namespace sparrowhawk {
class LinguisticStructure;
class LinguisticStructureDefaultTypeInternal;
extern LinguisticStructureDefaultTypeInternal _LinguisticStructure_default_instance_;
class Token;
class TokenDefaultTypeInternal;
extern TokenDefaultTypeInternal _Token_default_instance_;
class Utterance;
class UtteranceDefaultTypeInternal;
extern UtteranceDefaultTypeInternal _Utterance_default_instance_;
class Word;
class WordDefaultTypeInternal;
extern WordDefaultTypeInternal _Word_default_instance_;
}  // namespace sparrowhawk
}  // namespace speech
PROTOBUF_NAMESPACE_OPEN
template<> ::speech::sparrowhawk::LinguisticStructure* Arena::CreateMaybeMessage<::speech::sparrowhawk::LinguisticStructure>(Arena*);
template<> ::speech::sparrowhawk::Token* Arena::CreateMaybeMessage<::speech::sparrowhawk::Token>(Arena*);
template<> ::speech::sparrowhawk::Utterance* Arena::CreateMaybeMessage<::speech::sparrowhawk::Utterance>(Arena*);
template<> ::speech::sparrowhawk::Word* Arena::CreateMaybeMessage<::speech::sparrowhawk::Word>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace speech {
namespace sparrowhawk {

enum Token_Type : int {
  Token_Type_WORD = 1,
  Token_Type_SEMIOTIC_CLASS = 2,
  Token_Type_PUNCT = 3,
  Token_Type_WORD_NEEDS_VERBALIZATION = 4
};
bool Token_Type_IsValid(int value);
constexpr Token_Type Token_Type_Type_MIN = Token_Type_WORD;
constexpr Token_Type Token_Type_Type_MAX = Token_Type_WORD_NEEDS_VERBALIZATION;
constexpr int Token_Type_Type_ARRAYSIZE = Token_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Token_Type_descriptor();
template<typename T>
inline const std::string& Token_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Token_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Token_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Token_Type_descriptor(), enum_t_value);
}
inline bool Token_Type_Parse(
    const std::string& name, Token_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Token_Type>(
    Token_Type_descriptor(), name, value);
}
enum Token_PauseLength : int {
  Token_PauseLength_PAUSE_NONE = 0,
  Token_PauseLength_PAUSE_SHORT = 1,
  Token_PauseLength_PAUSE_MEDIUM = 2,
  Token_PauseLength_PAUSE_LONG = 3
};
bool Token_PauseLength_IsValid(int value);
constexpr Token_PauseLength Token_PauseLength_PauseLength_MIN = Token_PauseLength_PAUSE_NONE;
constexpr Token_PauseLength Token_PauseLength_PauseLength_MAX = Token_PauseLength_PAUSE_LONG;
constexpr int Token_PauseLength_PauseLength_ARRAYSIZE = Token_PauseLength_PauseLength_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Token_PauseLength_descriptor();
template<typename T>
inline const std::string& Token_PauseLength_Name(T enum_t_value) {
  static_assert(::std::is_same<T, Token_PauseLength>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function Token_PauseLength_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    Token_PauseLength_descriptor(), enum_t_value);
}
inline bool Token_PauseLength_Parse(
    const std::string& name, Token_PauseLength* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<Token_PauseLength>(
    Token_PauseLength_descriptor(), name, value);
}
// ===================================================================

class Token :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Token) */ {
 public:
  Token();
  virtual ~Token();

  Token(const Token& from);
  Token(Token&& from) noexcept
    : Token() {
    *this = ::std::move(from);
  }

  inline Token& operator=(const Token& from) {
    CopyFrom(from);
    return *this;
  }
  inline Token& operator=(Token&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Token& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Token* internal_default_instance() {
    return reinterpret_cast<const Token*>(
               &_Token_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Token& a, Token& b) {
    a.Swap(&b);
  }
  inline void Swap(Token* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Token* New() const final {
    return CreateMaybeMessage<Token>(nullptr);
  }

  Token* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Token>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Token& from);
  void MergeFrom(const Token& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Token* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.sparrowhawk.Token";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_items_2eproto);
    return ::descriptor_table_items_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef Token_Type Type;
  static constexpr Type WORD =
    Token_Type_WORD;
  static constexpr Type SEMIOTIC_CLASS =
    Token_Type_SEMIOTIC_CLASS;
  static constexpr Type PUNCT =
    Token_Type_PUNCT;
  static constexpr Type WORD_NEEDS_VERBALIZATION =
    Token_Type_WORD_NEEDS_VERBALIZATION;
  static inline bool Type_IsValid(int value) {
    return Token_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    Token_Type_Type_MIN;
  static constexpr Type Type_MAX =
    Token_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    Token_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return Token_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return Token_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(const std::string& name,
      Type* value) {
    return Token_Type_Parse(name, value);
  }

  typedef Token_PauseLength PauseLength;
  static constexpr PauseLength PAUSE_NONE =
    Token_PauseLength_PAUSE_NONE;
  static constexpr PauseLength PAUSE_SHORT =
    Token_PauseLength_PAUSE_SHORT;
  static constexpr PauseLength PAUSE_MEDIUM =
    Token_PauseLength_PAUSE_MEDIUM;
  static constexpr PauseLength PAUSE_LONG =
    Token_PauseLength_PAUSE_LONG;
  static inline bool PauseLength_IsValid(int value) {
    return Token_PauseLength_IsValid(value);
  }
  static constexpr PauseLength PauseLength_MIN =
    Token_PauseLength_PauseLength_MIN;
  static constexpr PauseLength PauseLength_MAX =
    Token_PauseLength_PauseLength_MAX;
  static constexpr int PauseLength_ARRAYSIZE =
    Token_PauseLength_PauseLength_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PauseLength_descriptor() {
    return Token_PauseLength_descriptor();
  }
  template<typename T>
  static inline const std::string& PauseLength_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PauseLength>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PauseLength_Name.");
    return Token_PauseLength_Name(enum_t_value);
  }
  static inline bool PauseLength_Parse(const std::string& name,
      PauseLength* value) {
    return Token_PauseLength_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 4,
    kWordidFieldNumber = 6,
    kSpellingFieldNumber = 7,
    kSpellingWithStressFieldNumber = 11,
    kDigitFieldNumber = 16,
    kVerbatimFieldNumber = 26,
    kLettersFieldNumber = 27,
    kLinksFieldNumber = 1,
    kCardinalFieldNumber = 14,
    kOrdinalFieldNumber = 15,
    kDecimalFieldNumber = 17,
    kFractionFieldNumber = 18,
    kTimeFieldNumber = 19,
    kMeasureFieldNumber = 20,
    kPercentFieldNumber = 21,
    kDateFieldNumber = 22,
    kTelephoneFieldNumber = 23,
    kMoneyFieldNumber = 24,
    kElectronicFieldNumber = 25,
    kConnectorFieldNumber = 28,
    kAbbreviationFieldNumber = 29,
    kStartIndexFieldNumber = 2,
    kEndIndexFieldNumber = 3,
    kPauseDurationFieldNumber = 9,
    kPauseLengthFieldNumber = 10,
    kPhraseBreakFieldNumber = 8,
    kSkipFieldNumber = 12,
    kNextSpaceFieldNumber = 13,
    kFirstDaughterFieldNumber = 30,
    kLastDaughterFieldNumber = 31,
    kTypeFieldNumber = 5,
  };
  // optional string name = 4;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string wordid = 6;
  bool has_wordid() const;
  private:
  bool _internal_has_wordid() const;
  public:
  void clear_wordid();
  const std::string& wordid() const;
  void set_wordid(const std::string& value);
  void set_wordid(std::string&& value);
  void set_wordid(const char* value);
  void set_wordid(const char* value, size_t size);
  std::string* mutable_wordid();
  std::string* release_wordid();
  void set_allocated_wordid(std::string* wordid);
  private:
  const std::string& _internal_wordid() const;
  void _internal_set_wordid(const std::string& value);
  std::string* _internal_mutable_wordid();
  public:

  // optional string spelling = 7;
  bool has_spelling() const;
  private:
  bool _internal_has_spelling() const;
  public:
  void clear_spelling();
  const std::string& spelling() const;
  void set_spelling(const std::string& value);
  void set_spelling(std::string&& value);
  void set_spelling(const char* value);
  void set_spelling(const char* value, size_t size);
  std::string* mutable_spelling();
  std::string* release_spelling();
  void set_allocated_spelling(std::string* spelling);
  private:
  const std::string& _internal_spelling() const;
  void _internal_set_spelling(const std::string& value);
  std::string* _internal_mutable_spelling();
  public:

  // optional string spelling_with_stress = 11;
  bool has_spelling_with_stress() const;
  private:
  bool _internal_has_spelling_with_stress() const;
  public:
  void clear_spelling_with_stress();
  const std::string& spelling_with_stress() const;
  void set_spelling_with_stress(const std::string& value);
  void set_spelling_with_stress(std::string&& value);
  void set_spelling_with_stress(const char* value);
  void set_spelling_with_stress(const char* value, size_t size);
  std::string* mutable_spelling_with_stress();
  std::string* release_spelling_with_stress();
  void set_allocated_spelling_with_stress(std::string* spelling_with_stress);
  private:
  const std::string& _internal_spelling_with_stress() const;
  void _internal_set_spelling_with_stress(const std::string& value);
  std::string* _internal_mutable_spelling_with_stress();
  public:

  // optional string digit = 16;
  bool has_digit() const;
  private:
  bool _internal_has_digit() const;
  public:
  void clear_digit();
  const std::string& digit() const;
  void set_digit(const std::string& value);
  void set_digit(std::string&& value);
  void set_digit(const char* value);
  void set_digit(const char* value, size_t size);
  std::string* mutable_digit();
  std::string* release_digit();
  void set_allocated_digit(std::string* digit);
  private:
  const std::string& _internal_digit() const;
  void _internal_set_digit(const std::string& value);
  std::string* _internal_mutable_digit();
  public:

  // optional string verbatim = 26;
  bool has_verbatim() const;
  private:
  bool _internal_has_verbatim() const;
  public:
  void clear_verbatim();
  const std::string& verbatim() const;
  void set_verbatim(const std::string& value);
  void set_verbatim(std::string&& value);
  void set_verbatim(const char* value);
  void set_verbatim(const char* value, size_t size);
  std::string* mutable_verbatim();
  std::string* release_verbatim();
  void set_allocated_verbatim(std::string* verbatim);
  private:
  const std::string& _internal_verbatim() const;
  void _internal_set_verbatim(const std::string& value);
  std::string* _internal_mutable_verbatim();
  public:

  // optional string letters = 27;
  bool has_letters() const;
  private:
  bool _internal_has_letters() const;
  public:
  void clear_letters();
  const std::string& letters() const;
  void set_letters(const std::string& value);
  void set_letters(std::string&& value);
  void set_letters(const char* value);
  void set_letters(const char* value, size_t size);
  std::string* mutable_letters();
  std::string* release_letters();
  void set_allocated_letters(std::string* letters);
  private:
  const std::string& _internal_letters() const;
  void _internal_set_letters(const std::string& value);
  std::string* _internal_mutable_letters();
  public:

  // optional .speech.sparrowhawk.Links links = 1;
  bool has_links() const;
  private:
  bool _internal_has_links() const;
  public:
  void clear_links();
  const ::speech::sparrowhawk::Links& links() const;
  ::speech::sparrowhawk::Links* release_links();
  ::speech::sparrowhawk::Links* mutable_links();
  void set_allocated_links(::speech::sparrowhawk::Links* links);
  private:
  const ::speech::sparrowhawk::Links& _internal_links() const;
  ::speech::sparrowhawk::Links* _internal_mutable_links();
  public:

  // optional .speech.sparrowhawk.Cardinal cardinal = 14;
  bool has_cardinal() const;
  private:
  bool _internal_has_cardinal() const;
  public:
  void clear_cardinal();
  const ::speech::sparrowhawk::Cardinal& cardinal() const;
  ::speech::sparrowhawk::Cardinal* release_cardinal();
  ::speech::sparrowhawk::Cardinal* mutable_cardinal();
  void set_allocated_cardinal(::speech::sparrowhawk::Cardinal* cardinal);
  private:
  const ::speech::sparrowhawk::Cardinal& _internal_cardinal() const;
  ::speech::sparrowhawk::Cardinal* _internal_mutable_cardinal();
  public:

  // optional .speech.sparrowhawk.Ordinal ordinal = 15;
  bool has_ordinal() const;
  private:
  bool _internal_has_ordinal() const;
  public:
  void clear_ordinal();
  const ::speech::sparrowhawk::Ordinal& ordinal() const;
  ::speech::sparrowhawk::Ordinal* release_ordinal();
  ::speech::sparrowhawk::Ordinal* mutable_ordinal();
  void set_allocated_ordinal(::speech::sparrowhawk::Ordinal* ordinal);
  private:
  const ::speech::sparrowhawk::Ordinal& _internal_ordinal() const;
  ::speech::sparrowhawk::Ordinal* _internal_mutable_ordinal();
  public:

  // optional .speech.sparrowhawk.Decimal decimal = 17;
  bool has_decimal() const;
  private:
  bool _internal_has_decimal() const;
  public:
  void clear_decimal();
  const ::speech::sparrowhawk::Decimal& decimal() const;
  ::speech::sparrowhawk::Decimal* release_decimal();
  ::speech::sparrowhawk::Decimal* mutable_decimal();
  void set_allocated_decimal(::speech::sparrowhawk::Decimal* decimal);
  private:
  const ::speech::sparrowhawk::Decimal& _internal_decimal() const;
  ::speech::sparrowhawk::Decimal* _internal_mutable_decimal();
  public:

  // optional .speech.sparrowhawk.Fraction fraction = 18;
  bool has_fraction() const;
  private:
  bool _internal_has_fraction() const;
  public:
  void clear_fraction();
  const ::speech::sparrowhawk::Fraction& fraction() const;
  ::speech::sparrowhawk::Fraction* release_fraction();
  ::speech::sparrowhawk::Fraction* mutable_fraction();
  void set_allocated_fraction(::speech::sparrowhawk::Fraction* fraction);
  private:
  const ::speech::sparrowhawk::Fraction& _internal_fraction() const;
  ::speech::sparrowhawk::Fraction* _internal_mutable_fraction();
  public:

  // optional .speech.sparrowhawk.Time time = 19;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  const ::speech::sparrowhawk::Time& time() const;
  ::speech::sparrowhawk::Time* release_time();
  ::speech::sparrowhawk::Time* mutable_time();
  void set_allocated_time(::speech::sparrowhawk::Time* time);
  private:
  const ::speech::sparrowhawk::Time& _internal_time() const;
  ::speech::sparrowhawk::Time* _internal_mutable_time();
  public:

  // optional .speech.sparrowhawk.Measure measure = 20;
  bool has_measure() const;
  private:
  bool _internal_has_measure() const;
  public:
  void clear_measure();
  const ::speech::sparrowhawk::Measure& measure() const;
  ::speech::sparrowhawk::Measure* release_measure();
  ::speech::sparrowhawk::Measure* mutable_measure();
  void set_allocated_measure(::speech::sparrowhawk::Measure* measure);
  private:
  const ::speech::sparrowhawk::Measure& _internal_measure() const;
  ::speech::sparrowhawk::Measure* _internal_mutable_measure();
  public:

  // optional .speech.sparrowhawk.Decimal percent = 21;
  bool has_percent() const;
  private:
  bool _internal_has_percent() const;
  public:
  void clear_percent();
  const ::speech::sparrowhawk::Decimal& percent() const;
  ::speech::sparrowhawk::Decimal* release_percent();
  ::speech::sparrowhawk::Decimal* mutable_percent();
  void set_allocated_percent(::speech::sparrowhawk::Decimal* percent);
  private:
  const ::speech::sparrowhawk::Decimal& _internal_percent() const;
  ::speech::sparrowhawk::Decimal* _internal_mutable_percent();
  public:

  // optional .speech.sparrowhawk.Date date = 22;
  bool has_date() const;
  private:
  bool _internal_has_date() const;
  public:
  void clear_date();
  const ::speech::sparrowhawk::Date& date() const;
  ::speech::sparrowhawk::Date* release_date();
  ::speech::sparrowhawk::Date* mutable_date();
  void set_allocated_date(::speech::sparrowhawk::Date* date);
  private:
  const ::speech::sparrowhawk::Date& _internal_date() const;
  ::speech::sparrowhawk::Date* _internal_mutable_date();
  public:

  // optional .speech.sparrowhawk.Telephone telephone = 23;
  bool has_telephone() const;
  private:
  bool _internal_has_telephone() const;
  public:
  void clear_telephone();
  const ::speech::sparrowhawk::Telephone& telephone() const;
  ::speech::sparrowhawk::Telephone* release_telephone();
  ::speech::sparrowhawk::Telephone* mutable_telephone();
  void set_allocated_telephone(::speech::sparrowhawk::Telephone* telephone);
  private:
  const ::speech::sparrowhawk::Telephone& _internal_telephone() const;
  ::speech::sparrowhawk::Telephone* _internal_mutable_telephone();
  public:

  // optional .speech.sparrowhawk.Money money = 24;
  bool has_money() const;
  private:
  bool _internal_has_money() const;
  public:
  void clear_money();
  const ::speech::sparrowhawk::Money& money() const;
  ::speech::sparrowhawk::Money* release_money();
  ::speech::sparrowhawk::Money* mutable_money();
  void set_allocated_money(::speech::sparrowhawk::Money* money);
  private:
  const ::speech::sparrowhawk::Money& _internal_money() const;
  ::speech::sparrowhawk::Money* _internal_mutable_money();
  public:

  // optional .speech.sparrowhawk.Electronic electronic = 25;
  bool has_electronic() const;
  private:
  bool _internal_has_electronic() const;
  public:
  void clear_electronic();
  const ::speech::sparrowhawk::Electronic& electronic() const;
  ::speech::sparrowhawk::Electronic* release_electronic();
  ::speech::sparrowhawk::Electronic* mutable_electronic();
  void set_allocated_electronic(::speech::sparrowhawk::Electronic* electronic);
  private:
  const ::speech::sparrowhawk::Electronic& _internal_electronic() const;
  ::speech::sparrowhawk::Electronic* _internal_mutable_electronic();
  public:

  // optional .speech.sparrowhawk.Connector connector = 28;
  bool has_connector() const;
  private:
  bool _internal_has_connector() const;
  public:
  void clear_connector();
  const ::speech::sparrowhawk::Connector& connector() const;
  ::speech::sparrowhawk::Connector* release_connector();
  ::speech::sparrowhawk::Connector* mutable_connector();
  void set_allocated_connector(::speech::sparrowhawk::Connector* connector);
  private:
  const ::speech::sparrowhawk::Connector& _internal_connector() const;
  ::speech::sparrowhawk::Connector* _internal_mutable_connector();
  public:

  // optional .speech.sparrowhawk.Abbreviation abbreviation = 29;
  bool has_abbreviation() const;
  private:
  bool _internal_has_abbreviation() const;
  public:
  void clear_abbreviation();
  const ::speech::sparrowhawk::Abbreviation& abbreviation() const;
  ::speech::sparrowhawk::Abbreviation* release_abbreviation();
  ::speech::sparrowhawk::Abbreviation* mutable_abbreviation();
  void set_allocated_abbreviation(::speech::sparrowhawk::Abbreviation* abbreviation);
  private:
  const ::speech::sparrowhawk::Abbreviation& _internal_abbreviation() const;
  ::speech::sparrowhawk::Abbreviation* _internal_mutable_abbreviation();
  public:

  // optional uint32 start_index = 2;
  bool has_start_index() const;
  private:
  bool _internal_has_start_index() const;
  public:
  void clear_start_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 start_index() const;
  void set_start_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_start_index() const;
  void _internal_set_start_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional uint32 end_index = 3;
  bool has_end_index() const;
  private:
  bool _internal_has_end_index() const;
  public:
  void clear_end_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 end_index() const;
  void set_end_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_end_index() const;
  void _internal_set_end_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // optional float pause_duration = 9;
  bool has_pause_duration() const;
  private:
  bool _internal_has_pause_duration() const;
  public:
  void clear_pause_duration();
  float pause_duration() const;
  void set_pause_duration(float value);
  private:
  float _internal_pause_duration() const;
  void _internal_set_pause_duration(float value);
  public:

  // optional .speech.sparrowhawk.Token.PauseLength pause_length = 10 [default = PAUSE_NONE];
  bool has_pause_length() const;
  private:
  bool _internal_has_pause_length() const;
  public:
  void clear_pause_length();
  ::speech::sparrowhawk::Token_PauseLength pause_length() const;
  void set_pause_length(::speech::sparrowhawk::Token_PauseLength value);
  private:
  ::speech::sparrowhawk::Token_PauseLength _internal_pause_length() const;
  void _internal_set_pause_length(::speech::sparrowhawk::Token_PauseLength value);
  public:

  // optional bool phrase_break = 8;
  bool has_phrase_break() const;
  private:
  bool _internal_has_phrase_break() const;
  public:
  void clear_phrase_break();
  bool phrase_break() const;
  void set_phrase_break(bool value);
  private:
  bool _internal_phrase_break() const;
  void _internal_set_phrase_break(bool value);
  public:

  // optional bool skip = 12;
  bool has_skip() const;
  private:
  bool _internal_has_skip() const;
  public:
  void clear_skip();
  bool skip() const;
  void set_skip(bool value);
  private:
  bool _internal_skip() const;
  void _internal_set_skip(bool value);
  public:

  // optional bool next_space = 13;
  bool has_next_space() const;
  private:
  bool _internal_has_next_space() const;
  public:
  void clear_next_space();
  bool next_space() const;
  void set_next_space(bool value);
  private:
  bool _internal_next_space() const;
  void _internal_set_next_space(bool value);
  public:

  // optional int32 first_daughter = 30;
  bool has_first_daughter() const;
  private:
  bool _internal_has_first_daughter() const;
  public:
  void clear_first_daughter();
  ::PROTOBUF_NAMESPACE_ID::int32 first_daughter() const;
  void set_first_daughter(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_first_daughter() const;
  void _internal_set_first_daughter(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 last_daughter = 31;
  bool has_last_daughter() const;
  private:
  bool _internal_has_last_daughter() const;
  public:
  void clear_last_daughter();
  ::PROTOBUF_NAMESPACE_ID::int32 last_daughter() const;
  void set_last_daughter(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_last_daughter() const;
  void _internal_set_last_daughter(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional .speech.sparrowhawk.Token.Type type = 5;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::speech::sparrowhawk::Token_Type type() const;
  void set_type(::speech::sparrowhawk::Token_Type value);
  private:
  ::speech::sparrowhawk::Token_Type _internal_type() const;
  void _internal_set_type(::speech::sparrowhawk::Token_Type value);
  public:

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Token)
  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Token)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr wordid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spelling_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spelling_with_stress_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr digit_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr verbatim_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr letters_;
  ::speech::sparrowhawk::Links* links_;
  ::speech::sparrowhawk::Cardinal* cardinal_;
  ::speech::sparrowhawk::Ordinal* ordinal_;
  ::speech::sparrowhawk::Decimal* decimal_;
  ::speech::sparrowhawk::Fraction* fraction_;
  ::speech::sparrowhawk::Time* time_;
  ::speech::sparrowhawk::Measure* measure_;
  ::speech::sparrowhawk::Decimal* percent_;
  ::speech::sparrowhawk::Date* date_;
  ::speech::sparrowhawk::Telephone* telephone_;
  ::speech::sparrowhawk::Money* money_;
  ::speech::sparrowhawk::Electronic* electronic_;
  ::speech::sparrowhawk::Connector* connector_;
  ::speech::sparrowhawk::Abbreviation* abbreviation_;
  ::PROTOBUF_NAMESPACE_ID::uint32 start_index_;
  ::PROTOBUF_NAMESPACE_ID::uint32 end_index_;
  float pause_duration_;
  int pause_length_;
  bool phrase_break_;
  bool skip_;
  bool next_space_;
  ::PROTOBUF_NAMESPACE_ID::int32 first_daughter_;
  ::PROTOBUF_NAMESPACE_ID::int32 last_daughter_;
  int type_;
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class Word :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Word) */ {
 public:
  Word();
  virtual ~Word();

  Word(const Word& from);
  Word(Word&& from) noexcept
    : Word() {
    *this = ::std::move(from);
  }

  inline Word& operator=(const Word& from) {
    CopyFrom(from);
    return *this;
  }
  inline Word& operator=(Word&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Word& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Word* internal_default_instance() {
    return reinterpret_cast<const Word*>(
               &_Word_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Word& a, Word& b) {
    a.Swap(&b);
  }
  inline void Swap(Word* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Word* New() const final {
    return CreateMaybeMessage<Word>(nullptr);
  }

  Word* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Word>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Word& from);
  void MergeFrom(const Word& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Word* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.sparrowhawk.Word";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_items_2eproto);
    return ::descriptor_table_items_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 2,
    kSpellingFieldNumber = 3,
    kLinksFieldNumber = 1,
    kPauseLengthFieldNumber = 4,
    kPrecedesPauseFieldNumber = 5,
    kParentFieldNumber = 6,
  };
  // optional string id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  const std::string& id() const;
  void set_id(const std::string& value);
  void set_id(std::string&& value);
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  std::string* mutable_id();
  std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // optional string spelling = 3;
  bool has_spelling() const;
  private:
  bool _internal_has_spelling() const;
  public:
  void clear_spelling();
  const std::string& spelling() const;
  void set_spelling(const std::string& value);
  void set_spelling(std::string&& value);
  void set_spelling(const char* value);
  void set_spelling(const char* value, size_t size);
  std::string* mutable_spelling();
  std::string* release_spelling();
  void set_allocated_spelling(std::string* spelling);
  private:
  const std::string& _internal_spelling() const;
  void _internal_set_spelling(const std::string& value);
  std::string* _internal_mutable_spelling();
  public:

  // optional .speech.sparrowhawk.Links links = 1;
  bool has_links() const;
  private:
  bool _internal_has_links() const;
  public:
  void clear_links();
  const ::speech::sparrowhawk::Links& links() const;
  ::speech::sparrowhawk::Links* release_links();
  ::speech::sparrowhawk::Links* mutable_links();
  void set_allocated_links(::speech::sparrowhawk::Links* links);
  private:
  const ::speech::sparrowhawk::Links& _internal_links() const;
  ::speech::sparrowhawk::Links* _internal_mutable_links();
  public:

  // optional float pause_length = 4;
  bool has_pause_length() const;
  private:
  bool _internal_has_pause_length() const;
  public:
  void clear_pause_length();
  float pause_length() const;
  void set_pause_length(float value);
  private:
  float _internal_pause_length() const;
  void _internal_set_pause_length(float value);
  public:

  // optional bool precedes_pause = 5;
  bool has_precedes_pause() const;
  private:
  bool _internal_has_precedes_pause() const;
  public:
  void clear_precedes_pause();
  bool precedes_pause() const;
  void set_precedes_pause(bool value);
  private:
  bool _internal_precedes_pause() const;
  void _internal_set_precedes_pause(bool value);
  public:

  // optional int32 parent = 6;
  bool has_parent() const;
  private:
  bool _internal_has_parent() const;
  public:
  void clear_parent();
  ::PROTOBUF_NAMESPACE_ID::int32 parent() const;
  void set_parent(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_parent() const;
  void _internal_set_parent(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Word)
  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Word)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spelling_;
  ::speech::sparrowhawk::Links* links_;
  float pause_length_;
  bool precedes_pause_;
  ::PROTOBUF_NAMESPACE_ID::int32 parent_;
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class LinguisticStructure :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.LinguisticStructure) */ {
 public:
  LinguisticStructure();
  virtual ~LinguisticStructure();

  LinguisticStructure(const LinguisticStructure& from);
  LinguisticStructure(LinguisticStructure&& from) noexcept
    : LinguisticStructure() {
    *this = ::std::move(from);
  }

  inline LinguisticStructure& operator=(const LinguisticStructure& from) {
    CopyFrom(from);
    return *this;
  }
  inline LinguisticStructure& operator=(LinguisticStructure&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const LinguisticStructure& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LinguisticStructure* internal_default_instance() {
    return reinterpret_cast<const LinguisticStructure*>(
               &_LinguisticStructure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LinguisticStructure& a, LinguisticStructure& b) {
    a.Swap(&b);
  }
  inline void Swap(LinguisticStructure* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LinguisticStructure* New() const final {
    return CreateMaybeMessage<LinguisticStructure>(nullptr);
  }

  LinguisticStructure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LinguisticStructure>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const LinguisticStructure& from);
  void MergeFrom(const LinguisticStructure& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LinguisticStructure* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.sparrowhawk.LinguisticStructure";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_items_2eproto);
    return ::descriptor_table_items_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokensFieldNumber = 3,
    kWordsFieldNumber = 4,
    kInputFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated .speech.sparrowhawk.Token tokens = 3;
  int tokens_size() const;
  private:
  int _internal_tokens_size() const;
  public:
  void clear_tokens();
  ::speech::sparrowhawk::Token* mutable_tokens(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speech::sparrowhawk::Token >*
      mutable_tokens();
  private:
  const ::speech::sparrowhawk::Token& _internal_tokens(int index) const;
  ::speech::sparrowhawk::Token* _internal_add_tokens();
  public:
  const ::speech::sparrowhawk::Token& tokens(int index) const;
  ::speech::sparrowhawk::Token* add_tokens();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speech::sparrowhawk::Token >&
      tokens() const;

  // repeated .speech.sparrowhawk.Word words = 4;
  int words_size() const;
  private:
  int _internal_words_size() const;
  public:
  void clear_words();
  ::speech::sparrowhawk::Word* mutable_words(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speech::sparrowhawk::Word >*
      mutable_words();
  private:
  const ::speech::sparrowhawk::Word& _internal_words(int index) const;
  ::speech::sparrowhawk::Word* _internal_add_words();
  public:
  const ::speech::sparrowhawk::Word& words(int index) const;
  ::speech::sparrowhawk::Word* add_words();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speech::sparrowhawk::Word >&
      words() const;

  // optional string input = 2;
  bool has_input() const;
  private:
  bool _internal_has_input() const;
  public:
  void clear_input();
  const std::string& input() const;
  void set_input(const std::string& value);
  void set_input(std::string&& value);
  void set_input(const char* value);
  void set_input(const char* value, size_t size);
  std::string* mutable_input();
  std::string* release_input();
  void set_allocated_input(std::string* input);
  private:
  const std::string& _internal_input() const;
  void _internal_set_input(const std::string& value);
  std::string* _internal_mutable_input();
  public:

  // optional int64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::int64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(LinguisticStructure)
  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.LinguisticStructure)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speech::sparrowhawk::Token > tokens_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speech::sparrowhawk::Word > words_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr input_;
  ::PROTOBUF_NAMESPACE_ID::int64 id_;
  friend struct ::TableStruct_items_2eproto;
};
// -------------------------------------------------------------------

class Utterance :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Utterance) */ {
 public:
  Utterance();
  virtual ~Utterance();

  Utterance(const Utterance& from);
  Utterance(Utterance&& from) noexcept
    : Utterance() {
    *this = ::std::move(from);
  }

  inline Utterance& operator=(const Utterance& from) {
    CopyFrom(from);
    return *this;
  }
  inline Utterance& operator=(Utterance&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Utterance& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Utterance* internal_default_instance() {
    return reinterpret_cast<const Utterance*>(
               &_Utterance_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Utterance& a, Utterance& b) {
    a.Swap(&b);
  }
  inline void Swap(Utterance* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Utterance* New() const final {
    return CreateMaybeMessage<Utterance>(nullptr);
  }

  Utterance* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Utterance>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Utterance& from);
  void MergeFrom(const Utterance& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Utterance* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.sparrowhawk.Utterance";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_items_2eproto);
    return ::descriptor_table_items_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSegmenterOutputFieldNumber = 5,
    kFilenameFieldNumber = 2,
    kSentenceFieldNumber = 3,
    kOriginalSentenceFieldNumber = 4,
    kLinguisticFieldNumber = 6,
    kIdFieldNumber = 1,
  };
  // repeated string segmenter_output = 5;
  int segmenter_output_size() const;
  private:
  int _internal_segmenter_output_size() const;
  public:
  void clear_segmenter_output();
  const std::string& segmenter_output(int index) const;
  std::string* mutable_segmenter_output(int index);
  void set_segmenter_output(int index, const std::string& value);
  void set_segmenter_output(int index, std::string&& value);
  void set_segmenter_output(int index, const char* value);
  void set_segmenter_output(int index, const char* value, size_t size);
  std::string* add_segmenter_output();
  void add_segmenter_output(const std::string& value);
  void add_segmenter_output(std::string&& value);
  void add_segmenter_output(const char* value);
  void add_segmenter_output(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& segmenter_output() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_segmenter_output();
  private:
  const std::string& _internal_segmenter_output(int index) const;
  std::string* _internal_add_segmenter_output();
  public:

  // optional string filename = 2;
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  void set_filename(const std::string& value);
  void set_filename(std::string&& value);
  void set_filename(const char* value);
  void set_filename(const char* value, size_t size);
  std::string* mutable_filename();
  std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // optional string sentence = 3;
  bool has_sentence() const;
  private:
  bool _internal_has_sentence() const;
  public:
  void clear_sentence();
  const std::string& sentence() const;
  void set_sentence(const std::string& value);
  void set_sentence(std::string&& value);
  void set_sentence(const char* value);
  void set_sentence(const char* value, size_t size);
  std::string* mutable_sentence();
  std::string* release_sentence();
  void set_allocated_sentence(std::string* sentence);
  private:
  const std::string& _internal_sentence() const;
  void _internal_set_sentence(const std::string& value);
  std::string* _internal_mutable_sentence();
  public:

  // optional string original_sentence = 4;
  bool has_original_sentence() const;
  private:
  bool _internal_has_original_sentence() const;
  public:
  void clear_original_sentence();
  const std::string& original_sentence() const;
  void set_original_sentence(const std::string& value);
  void set_original_sentence(std::string&& value);
  void set_original_sentence(const char* value);
  void set_original_sentence(const char* value, size_t size);
  std::string* mutable_original_sentence();
  std::string* release_original_sentence();
  void set_allocated_original_sentence(std::string* original_sentence);
  private:
  const std::string& _internal_original_sentence() const;
  void _internal_set_original_sentence(const std::string& value);
  std::string* _internal_mutable_original_sentence();
  public:

  // optional .speech.sparrowhawk.LinguisticStructure linguistic = 6;
  bool has_linguistic() const;
  private:
  bool _internal_has_linguistic() const;
  public:
  void clear_linguistic();
  const ::speech::sparrowhawk::LinguisticStructure& linguistic() const;
  ::speech::sparrowhawk::LinguisticStructure* release_linguistic();
  ::speech::sparrowhawk::LinguisticStructure* mutable_linguistic();
  void set_allocated_linguistic(::speech::sparrowhawk::LinguisticStructure* linguistic);
  private:
  const ::speech::sparrowhawk::LinguisticStructure& _internal_linguistic() const;
  ::speech::sparrowhawk::LinguisticStructure* _internal_mutable_linguistic();
  public:

  // optional uint64 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint64 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(Utterance)
  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Utterance)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::ExtensionSet _extensions_;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> segmenter_output_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sentence_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr original_sentence_;
  ::speech::sparrowhawk::LinguisticStructure* linguistic_;
  ::PROTOBUF_NAMESPACE_ID::uint64 id_;
  friend struct ::TableStruct_items_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Token

// optional .speech.sparrowhawk.Links links = 1;
inline bool Token::_internal_has_links() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || links_ != nullptr);
  return value;
}
inline bool Token::has_links() const {
  return _internal_has_links();
}
inline const ::speech::sparrowhawk::Links& Token::_internal_links() const {
  const ::speech::sparrowhawk::Links* p = links_;
  return p != nullptr ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Links*>(
      &::speech::sparrowhawk::_Links_default_instance_);
}
inline const ::speech::sparrowhawk::Links& Token::links() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.links)
  return _internal_links();
}
inline ::speech::sparrowhawk::Links* Token::release_links() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.links)
  _has_bits_[0] &= ~0x00000080u;
  ::speech::sparrowhawk::Links* temp = links_;
  links_ = nullptr;
  return temp;
}
inline ::speech::sparrowhawk::Links* Token::_internal_mutable_links() {
  _has_bits_[0] |= 0x00000080u;
  if (links_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::sparrowhawk::Links>(GetArenaNoVirtual());
    links_ = p;
  }
  return links_;
}
inline ::speech::sparrowhawk::Links* Token::mutable_links() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.links)
  return _internal_mutable_links();
}
inline void Token::set_allocated_links(::speech::sparrowhawk::Links* links) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(links_);
  }
  if (links) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      links = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, links, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  links_ = links;
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.links)
}

// optional uint32 start_index = 2;
inline bool Token::_internal_has_start_index() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool Token::has_start_index() const {
  return _internal_has_start_index();
}
inline void Token::clear_start_index() {
  start_index_ = 0u;
  _has_bits_[0] &= ~0x00200000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Token::_internal_start_index() const {
  return start_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Token::start_index() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.start_index)
  return _internal_start_index();
}
inline void Token::_internal_set_start_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00200000u;
  start_index_ = value;
}
inline void Token::set_start_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_start_index(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.start_index)
}

// optional uint32 end_index = 3;
inline bool Token::_internal_has_end_index() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool Token::has_end_index() const {
  return _internal_has_end_index();
}
inline void Token::clear_end_index() {
  end_index_ = 0u;
  _has_bits_[0] &= ~0x00400000u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Token::_internal_end_index() const {
  return end_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Token::end_index() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.end_index)
  return _internal_end_index();
}
inline void Token::_internal_set_end_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00400000u;
  end_index_ = value;
}
inline void Token::set_end_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_end_index(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.end_index)
}

// optional string name = 4;
inline bool Token::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Token::has_name() const {
  return _internal_has_name();
}
inline void Token::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Token::name() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.name)
  return _internal_name();
}
inline void Token::set_name(const std::string& value) {
  _internal_set_name(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.name)
}
inline std::string* Token::mutable_name() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.name)
  return _internal_mutable_name();
}
inline const std::string& Token::_internal_name() const {
  return name_.GetNoArena();
}
inline void Token::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Token::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Token.name)
}
inline void Token::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Token.name)
}
inline void Token::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Token.name)
}
inline std::string* Token::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Token::release_name() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.name)
}

// optional .speech.sparrowhawk.Token.Type type = 5;
inline bool Token::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x40000000u) != 0;
  return value;
}
inline bool Token::has_type() const {
  return _internal_has_type();
}
inline void Token::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x40000000u;
}
inline ::speech::sparrowhawk::Token_Type Token::_internal_type() const {
  return static_cast< ::speech::sparrowhawk::Token_Type >(type_);
}
inline ::speech::sparrowhawk::Token_Type Token::type() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.type)
  return _internal_type();
}
inline void Token::_internal_set_type(::speech::sparrowhawk::Token_Type value) {
  assert(::speech::sparrowhawk::Token_Type_IsValid(value));
  _has_bits_[0] |= 0x40000000u;
  type_ = value;
}
inline void Token::set_type(::speech::sparrowhawk::Token_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.type)
}

// optional string wordid = 6;
inline bool Token::_internal_has_wordid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Token::has_wordid() const {
  return _internal_has_wordid();
}
inline void Token::clear_wordid() {
  wordid_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Token::wordid() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.wordid)
  return _internal_wordid();
}
inline void Token::set_wordid(const std::string& value) {
  _internal_set_wordid(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.wordid)
}
inline std::string* Token::mutable_wordid() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.wordid)
  return _internal_mutable_wordid();
}
inline const std::string& Token::_internal_wordid() const {
  return wordid_.GetNoArena();
}
inline void Token::_internal_set_wordid(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  wordid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Token::set_wordid(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  wordid_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Token.wordid)
}
inline void Token::set_wordid(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  wordid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Token.wordid)
}
inline void Token::set_wordid(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  wordid_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Token.wordid)
}
inline std::string* Token::_internal_mutable_wordid() {
  _has_bits_[0] |= 0x00000002u;
  return wordid_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Token::release_wordid() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.wordid)
  if (!_internal_has_wordid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return wordid_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_wordid(std::string* wordid) {
  if (wordid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  wordid_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), wordid);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.wordid)
}

// optional string spelling = 7;
inline bool Token::_internal_has_spelling() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Token::has_spelling() const {
  return _internal_has_spelling();
}
inline void Token::clear_spelling() {
  spelling_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Token::spelling() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.spelling)
  return _internal_spelling();
}
inline void Token::set_spelling(const std::string& value) {
  _internal_set_spelling(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.spelling)
}
inline std::string* Token::mutable_spelling() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.spelling)
  return _internal_mutable_spelling();
}
inline const std::string& Token::_internal_spelling() const {
  return spelling_.GetNoArena();
}
inline void Token::_internal_set_spelling(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  spelling_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Token::set_spelling(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  spelling_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Token.spelling)
}
inline void Token::set_spelling(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  spelling_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Token.spelling)
}
inline void Token::set_spelling(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  spelling_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Token.spelling)
}
inline std::string* Token::_internal_mutable_spelling() {
  _has_bits_[0] |= 0x00000004u;
  return spelling_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Token::release_spelling() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.spelling)
  if (!_internal_has_spelling()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return spelling_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_spelling(std::string* spelling) {
  if (spelling != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  spelling_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), spelling);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.spelling)
}

// optional bool phrase_break = 8;
inline bool Token::_internal_has_phrase_break() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool Token::has_phrase_break() const {
  return _internal_has_phrase_break();
}
inline void Token::clear_phrase_break() {
  phrase_break_ = false;
  _has_bits_[0] &= ~0x02000000u;
}
inline bool Token::_internal_phrase_break() const {
  return phrase_break_;
}
inline bool Token::phrase_break() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.phrase_break)
  return _internal_phrase_break();
}
inline void Token::_internal_set_phrase_break(bool value) {
  _has_bits_[0] |= 0x02000000u;
  phrase_break_ = value;
}
inline void Token::set_phrase_break(bool value) {
  _internal_set_phrase_break(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.phrase_break)
}

// optional float pause_duration = 9;
inline bool Token::_internal_has_pause_duration() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool Token::has_pause_duration() const {
  return _internal_has_pause_duration();
}
inline void Token::clear_pause_duration() {
  pause_duration_ = 0;
  _has_bits_[0] &= ~0x00800000u;
}
inline float Token::_internal_pause_duration() const {
  return pause_duration_;
}
inline float Token::pause_duration() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.pause_duration)
  return _internal_pause_duration();
}
inline void Token::_internal_set_pause_duration(float value) {
  _has_bits_[0] |= 0x00800000u;
  pause_duration_ = value;
}
inline void Token::set_pause_duration(float value) {
  _internal_set_pause_duration(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.pause_duration)
}

// optional .speech.sparrowhawk.Token.PauseLength pause_length = 10 [default = PAUSE_NONE];
inline bool Token::_internal_has_pause_length() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool Token::has_pause_length() const {
  return _internal_has_pause_length();
}
inline void Token::clear_pause_length() {
  pause_length_ = 0;
  _has_bits_[0] &= ~0x01000000u;
}
inline ::speech::sparrowhawk::Token_PauseLength Token::_internal_pause_length() const {
  return static_cast< ::speech::sparrowhawk::Token_PauseLength >(pause_length_);
}
inline ::speech::sparrowhawk::Token_PauseLength Token::pause_length() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.pause_length)
  return _internal_pause_length();
}
inline void Token::_internal_set_pause_length(::speech::sparrowhawk::Token_PauseLength value) {
  assert(::speech::sparrowhawk::Token_PauseLength_IsValid(value));
  _has_bits_[0] |= 0x01000000u;
  pause_length_ = value;
}
inline void Token::set_pause_length(::speech::sparrowhawk::Token_PauseLength value) {
  _internal_set_pause_length(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.pause_length)
}

// optional string spelling_with_stress = 11;
inline bool Token::_internal_has_spelling_with_stress() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Token::has_spelling_with_stress() const {
  return _internal_has_spelling_with_stress();
}
inline void Token::clear_spelling_with_stress() {
  spelling_with_stress_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Token::spelling_with_stress() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.spelling_with_stress)
  return _internal_spelling_with_stress();
}
inline void Token::set_spelling_with_stress(const std::string& value) {
  _internal_set_spelling_with_stress(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.spelling_with_stress)
}
inline std::string* Token::mutable_spelling_with_stress() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.spelling_with_stress)
  return _internal_mutable_spelling_with_stress();
}
inline const std::string& Token::_internal_spelling_with_stress() const {
  return spelling_with_stress_.GetNoArena();
}
inline void Token::_internal_set_spelling_with_stress(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  spelling_with_stress_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Token::set_spelling_with_stress(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  spelling_with_stress_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Token.spelling_with_stress)
}
inline void Token::set_spelling_with_stress(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  spelling_with_stress_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Token.spelling_with_stress)
}
inline void Token::set_spelling_with_stress(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000008u;
  spelling_with_stress_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Token.spelling_with_stress)
}
inline std::string* Token::_internal_mutable_spelling_with_stress() {
  _has_bits_[0] |= 0x00000008u;
  return spelling_with_stress_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Token::release_spelling_with_stress() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.spelling_with_stress)
  if (!_internal_has_spelling_with_stress()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return spelling_with_stress_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_spelling_with_stress(std::string* spelling_with_stress) {
  if (spelling_with_stress != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  spelling_with_stress_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), spelling_with_stress);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.spelling_with_stress)
}

// optional bool skip = 12;
inline bool Token::_internal_has_skip() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool Token::has_skip() const {
  return _internal_has_skip();
}
inline void Token::clear_skip() {
  skip_ = false;
  _has_bits_[0] &= ~0x04000000u;
}
inline bool Token::_internal_skip() const {
  return skip_;
}
inline bool Token::skip() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.skip)
  return _internal_skip();
}
inline void Token::_internal_set_skip(bool value) {
  _has_bits_[0] |= 0x04000000u;
  skip_ = value;
}
inline void Token::set_skip(bool value) {
  _internal_set_skip(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.skip)
}

// optional bool next_space = 13;
inline bool Token::_internal_has_next_space() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool Token::has_next_space() const {
  return _internal_has_next_space();
}
inline void Token::clear_next_space() {
  next_space_ = false;
  _has_bits_[0] &= ~0x08000000u;
}
inline bool Token::_internal_next_space() const {
  return next_space_;
}
inline bool Token::next_space() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.next_space)
  return _internal_next_space();
}
inline void Token::_internal_set_next_space(bool value) {
  _has_bits_[0] |= 0x08000000u;
  next_space_ = value;
}
inline void Token::set_next_space(bool value) {
  _internal_set_next_space(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.next_space)
}

// optional .speech.sparrowhawk.Cardinal cardinal = 14;
inline bool Token::_internal_has_cardinal() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || cardinal_ != nullptr);
  return value;
}
inline bool Token::has_cardinal() const {
  return _internal_has_cardinal();
}
inline const ::speech::sparrowhawk::Cardinal& Token::_internal_cardinal() const {
  const ::speech::sparrowhawk::Cardinal* p = cardinal_;
  return p != nullptr ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Cardinal*>(
      &::speech::sparrowhawk::_Cardinal_default_instance_);
}
inline const ::speech::sparrowhawk::Cardinal& Token::cardinal() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.cardinal)
  return _internal_cardinal();
}
inline ::speech::sparrowhawk::Cardinal* Token::release_cardinal() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.cardinal)
  _has_bits_[0] &= ~0x00000100u;
  ::speech::sparrowhawk::Cardinal* temp = cardinal_;
  cardinal_ = nullptr;
  return temp;
}
inline ::speech::sparrowhawk::Cardinal* Token::_internal_mutable_cardinal() {
  _has_bits_[0] |= 0x00000100u;
  if (cardinal_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::sparrowhawk::Cardinal>(GetArenaNoVirtual());
    cardinal_ = p;
  }
  return cardinal_;
}
inline ::speech::sparrowhawk::Cardinal* Token::mutable_cardinal() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.cardinal)
  return _internal_mutable_cardinal();
}
inline void Token::set_allocated_cardinal(::speech::sparrowhawk::Cardinal* cardinal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(cardinal_);
  }
  if (cardinal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cardinal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cardinal, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  cardinal_ = cardinal;
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.cardinal)
}

// optional .speech.sparrowhawk.Ordinal ordinal = 15;
inline bool Token::_internal_has_ordinal() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || ordinal_ != nullptr);
  return value;
}
inline bool Token::has_ordinal() const {
  return _internal_has_ordinal();
}
inline const ::speech::sparrowhawk::Ordinal& Token::_internal_ordinal() const {
  const ::speech::sparrowhawk::Ordinal* p = ordinal_;
  return p != nullptr ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Ordinal*>(
      &::speech::sparrowhawk::_Ordinal_default_instance_);
}
inline const ::speech::sparrowhawk::Ordinal& Token::ordinal() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.ordinal)
  return _internal_ordinal();
}
inline ::speech::sparrowhawk::Ordinal* Token::release_ordinal() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.ordinal)
  _has_bits_[0] &= ~0x00000200u;
  ::speech::sparrowhawk::Ordinal* temp = ordinal_;
  ordinal_ = nullptr;
  return temp;
}
inline ::speech::sparrowhawk::Ordinal* Token::_internal_mutable_ordinal() {
  _has_bits_[0] |= 0x00000200u;
  if (ordinal_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::sparrowhawk::Ordinal>(GetArenaNoVirtual());
    ordinal_ = p;
  }
  return ordinal_;
}
inline ::speech::sparrowhawk::Ordinal* Token::mutable_ordinal() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.ordinal)
  return _internal_mutable_ordinal();
}
inline void Token::set_allocated_ordinal(::speech::sparrowhawk::Ordinal* ordinal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ordinal_);
  }
  if (ordinal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ordinal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ordinal, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  ordinal_ = ordinal;
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.ordinal)
}

// optional string digit = 16;
inline bool Token::_internal_has_digit() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Token::has_digit() const {
  return _internal_has_digit();
}
inline void Token::clear_digit() {
  digit_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Token::digit() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.digit)
  return _internal_digit();
}
inline void Token::set_digit(const std::string& value) {
  _internal_set_digit(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.digit)
}
inline std::string* Token::mutable_digit() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.digit)
  return _internal_mutable_digit();
}
inline const std::string& Token::_internal_digit() const {
  return digit_.GetNoArena();
}
inline void Token::_internal_set_digit(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  digit_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Token::set_digit(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  digit_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Token.digit)
}
inline void Token::set_digit(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  digit_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Token.digit)
}
inline void Token::set_digit(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000010u;
  digit_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Token.digit)
}
inline std::string* Token::_internal_mutable_digit() {
  _has_bits_[0] |= 0x00000010u;
  return digit_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Token::release_digit() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.digit)
  if (!_internal_has_digit()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return digit_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_digit(std::string* digit) {
  if (digit != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  digit_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), digit);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.digit)
}

// optional .speech.sparrowhawk.Decimal decimal = 17;
inline bool Token::_internal_has_decimal() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || decimal_ != nullptr);
  return value;
}
inline bool Token::has_decimal() const {
  return _internal_has_decimal();
}
inline const ::speech::sparrowhawk::Decimal& Token::_internal_decimal() const {
  const ::speech::sparrowhawk::Decimal* p = decimal_;
  return p != nullptr ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Decimal*>(
      &::speech::sparrowhawk::_Decimal_default_instance_);
}
inline const ::speech::sparrowhawk::Decimal& Token::decimal() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.decimal)
  return _internal_decimal();
}
inline ::speech::sparrowhawk::Decimal* Token::release_decimal() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.decimal)
  _has_bits_[0] &= ~0x00000400u;
  ::speech::sparrowhawk::Decimal* temp = decimal_;
  decimal_ = nullptr;
  return temp;
}
inline ::speech::sparrowhawk::Decimal* Token::_internal_mutable_decimal() {
  _has_bits_[0] |= 0x00000400u;
  if (decimal_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::sparrowhawk::Decimal>(GetArenaNoVirtual());
    decimal_ = p;
  }
  return decimal_;
}
inline ::speech::sparrowhawk::Decimal* Token::mutable_decimal() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.decimal)
  return _internal_mutable_decimal();
}
inline void Token::set_allocated_decimal(::speech::sparrowhawk::Decimal* decimal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(decimal_);
  }
  if (decimal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      decimal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, decimal, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  decimal_ = decimal;
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.decimal)
}

// optional .speech.sparrowhawk.Fraction fraction = 18;
inline bool Token::_internal_has_fraction() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || fraction_ != nullptr);
  return value;
}
inline bool Token::has_fraction() const {
  return _internal_has_fraction();
}
inline const ::speech::sparrowhawk::Fraction& Token::_internal_fraction() const {
  const ::speech::sparrowhawk::Fraction* p = fraction_;
  return p != nullptr ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Fraction*>(
      &::speech::sparrowhawk::_Fraction_default_instance_);
}
inline const ::speech::sparrowhawk::Fraction& Token::fraction() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.fraction)
  return _internal_fraction();
}
inline ::speech::sparrowhawk::Fraction* Token::release_fraction() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.fraction)
  _has_bits_[0] &= ~0x00000800u;
  ::speech::sparrowhawk::Fraction* temp = fraction_;
  fraction_ = nullptr;
  return temp;
}
inline ::speech::sparrowhawk::Fraction* Token::_internal_mutable_fraction() {
  _has_bits_[0] |= 0x00000800u;
  if (fraction_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::sparrowhawk::Fraction>(GetArenaNoVirtual());
    fraction_ = p;
  }
  return fraction_;
}
inline ::speech::sparrowhawk::Fraction* Token::mutable_fraction() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.fraction)
  return _internal_mutable_fraction();
}
inline void Token::set_allocated_fraction(::speech::sparrowhawk::Fraction* fraction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(fraction_);
  }
  if (fraction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fraction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fraction, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  fraction_ = fraction;
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.fraction)
}

// optional .speech.sparrowhawk.Time time = 19;
inline bool Token::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || time_ != nullptr);
  return value;
}
inline bool Token::has_time() const {
  return _internal_has_time();
}
inline const ::speech::sparrowhawk::Time& Token::_internal_time() const {
  const ::speech::sparrowhawk::Time* p = time_;
  return p != nullptr ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Time*>(
      &::speech::sparrowhawk::_Time_default_instance_);
}
inline const ::speech::sparrowhawk::Time& Token::time() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.time)
  return _internal_time();
}
inline ::speech::sparrowhawk::Time* Token::release_time() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.time)
  _has_bits_[0] &= ~0x00001000u;
  ::speech::sparrowhawk::Time* temp = time_;
  time_ = nullptr;
  return temp;
}
inline ::speech::sparrowhawk::Time* Token::_internal_mutable_time() {
  _has_bits_[0] |= 0x00001000u;
  if (time_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::sparrowhawk::Time>(GetArenaNoVirtual());
    time_ = p;
  }
  return time_;
}
inline ::speech::sparrowhawk::Time* Token::mutable_time() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.time)
  return _internal_mutable_time();
}
inline void Token::set_allocated_time(::speech::sparrowhawk::Time* time) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(time_);
  }
  if (time) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      time = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, time, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  time_ = time;
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.time)
}

// optional .speech.sparrowhawk.Measure measure = 20;
inline bool Token::_internal_has_measure() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || measure_ != nullptr);
  return value;
}
inline bool Token::has_measure() const {
  return _internal_has_measure();
}
inline const ::speech::sparrowhawk::Measure& Token::_internal_measure() const {
  const ::speech::sparrowhawk::Measure* p = measure_;
  return p != nullptr ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Measure*>(
      &::speech::sparrowhawk::_Measure_default_instance_);
}
inline const ::speech::sparrowhawk::Measure& Token::measure() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.measure)
  return _internal_measure();
}
inline ::speech::sparrowhawk::Measure* Token::release_measure() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.measure)
  _has_bits_[0] &= ~0x00002000u;
  ::speech::sparrowhawk::Measure* temp = measure_;
  measure_ = nullptr;
  return temp;
}
inline ::speech::sparrowhawk::Measure* Token::_internal_mutable_measure() {
  _has_bits_[0] |= 0x00002000u;
  if (measure_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::sparrowhawk::Measure>(GetArenaNoVirtual());
    measure_ = p;
  }
  return measure_;
}
inline ::speech::sparrowhawk::Measure* Token::mutable_measure() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.measure)
  return _internal_mutable_measure();
}
inline void Token::set_allocated_measure(::speech::sparrowhawk::Measure* measure) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(measure_);
  }
  if (measure) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      measure = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, measure, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  measure_ = measure;
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.measure)
}

// optional .speech.sparrowhawk.Decimal percent = 21;
inline bool Token::_internal_has_percent() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || percent_ != nullptr);
  return value;
}
inline bool Token::has_percent() const {
  return _internal_has_percent();
}
inline const ::speech::sparrowhawk::Decimal& Token::_internal_percent() const {
  const ::speech::sparrowhawk::Decimal* p = percent_;
  return p != nullptr ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Decimal*>(
      &::speech::sparrowhawk::_Decimal_default_instance_);
}
inline const ::speech::sparrowhawk::Decimal& Token::percent() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.percent)
  return _internal_percent();
}
inline ::speech::sparrowhawk::Decimal* Token::release_percent() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.percent)
  _has_bits_[0] &= ~0x00004000u;
  ::speech::sparrowhawk::Decimal* temp = percent_;
  percent_ = nullptr;
  return temp;
}
inline ::speech::sparrowhawk::Decimal* Token::_internal_mutable_percent() {
  _has_bits_[0] |= 0x00004000u;
  if (percent_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::sparrowhawk::Decimal>(GetArenaNoVirtual());
    percent_ = p;
  }
  return percent_;
}
inline ::speech::sparrowhawk::Decimal* Token::mutable_percent() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.percent)
  return _internal_mutable_percent();
}
inline void Token::set_allocated_percent(::speech::sparrowhawk::Decimal* percent) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(percent_);
  }
  if (percent) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      percent = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, percent, submessage_arena);
    }
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  percent_ = percent;
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.percent)
}

// optional .speech.sparrowhawk.Date date = 22;
inline bool Token::_internal_has_date() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || date_ != nullptr);
  return value;
}
inline bool Token::has_date() const {
  return _internal_has_date();
}
inline const ::speech::sparrowhawk::Date& Token::_internal_date() const {
  const ::speech::sparrowhawk::Date* p = date_;
  return p != nullptr ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Date*>(
      &::speech::sparrowhawk::_Date_default_instance_);
}
inline const ::speech::sparrowhawk::Date& Token::date() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.date)
  return _internal_date();
}
inline ::speech::sparrowhawk::Date* Token::release_date() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.date)
  _has_bits_[0] &= ~0x00008000u;
  ::speech::sparrowhawk::Date* temp = date_;
  date_ = nullptr;
  return temp;
}
inline ::speech::sparrowhawk::Date* Token::_internal_mutable_date() {
  _has_bits_[0] |= 0x00008000u;
  if (date_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::sparrowhawk::Date>(GetArenaNoVirtual());
    date_ = p;
  }
  return date_;
}
inline ::speech::sparrowhawk::Date* Token::mutable_date() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.date)
  return _internal_mutable_date();
}
inline void Token::set_allocated_date(::speech::sparrowhawk::Date* date) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(date_);
  }
  if (date) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      date = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, date, submessage_arena);
    }
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  date_ = date;
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.date)
}

// optional .speech.sparrowhawk.Telephone telephone = 23;
inline bool Token::_internal_has_telephone() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || telephone_ != nullptr);
  return value;
}
inline bool Token::has_telephone() const {
  return _internal_has_telephone();
}
inline const ::speech::sparrowhawk::Telephone& Token::_internal_telephone() const {
  const ::speech::sparrowhawk::Telephone* p = telephone_;
  return p != nullptr ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Telephone*>(
      &::speech::sparrowhawk::_Telephone_default_instance_);
}
inline const ::speech::sparrowhawk::Telephone& Token::telephone() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.telephone)
  return _internal_telephone();
}
inline ::speech::sparrowhawk::Telephone* Token::release_telephone() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.telephone)
  _has_bits_[0] &= ~0x00010000u;
  ::speech::sparrowhawk::Telephone* temp = telephone_;
  telephone_ = nullptr;
  return temp;
}
inline ::speech::sparrowhawk::Telephone* Token::_internal_mutable_telephone() {
  _has_bits_[0] |= 0x00010000u;
  if (telephone_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::sparrowhawk::Telephone>(GetArenaNoVirtual());
    telephone_ = p;
  }
  return telephone_;
}
inline ::speech::sparrowhawk::Telephone* Token::mutable_telephone() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.telephone)
  return _internal_mutable_telephone();
}
inline void Token::set_allocated_telephone(::speech::sparrowhawk::Telephone* telephone) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(telephone_);
  }
  if (telephone) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      telephone = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, telephone, submessage_arena);
    }
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  telephone_ = telephone;
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.telephone)
}

// optional .speech.sparrowhawk.Money money = 24;
inline bool Token::_internal_has_money() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  PROTOBUF_ASSUME(!value || money_ != nullptr);
  return value;
}
inline bool Token::has_money() const {
  return _internal_has_money();
}
inline const ::speech::sparrowhawk::Money& Token::_internal_money() const {
  const ::speech::sparrowhawk::Money* p = money_;
  return p != nullptr ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Money*>(
      &::speech::sparrowhawk::_Money_default_instance_);
}
inline const ::speech::sparrowhawk::Money& Token::money() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.money)
  return _internal_money();
}
inline ::speech::sparrowhawk::Money* Token::release_money() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.money)
  _has_bits_[0] &= ~0x00020000u;
  ::speech::sparrowhawk::Money* temp = money_;
  money_ = nullptr;
  return temp;
}
inline ::speech::sparrowhawk::Money* Token::_internal_mutable_money() {
  _has_bits_[0] |= 0x00020000u;
  if (money_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::sparrowhawk::Money>(GetArenaNoVirtual());
    money_ = p;
  }
  return money_;
}
inline ::speech::sparrowhawk::Money* Token::mutable_money() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.money)
  return _internal_mutable_money();
}
inline void Token::set_allocated_money(::speech::sparrowhawk::Money* money) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(money_);
  }
  if (money) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      money = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, money, submessage_arena);
    }
    _has_bits_[0] |= 0x00020000u;
  } else {
    _has_bits_[0] &= ~0x00020000u;
  }
  money_ = money;
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.money)
}

// optional .speech.sparrowhawk.Electronic electronic = 25;
inline bool Token::_internal_has_electronic() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  PROTOBUF_ASSUME(!value || electronic_ != nullptr);
  return value;
}
inline bool Token::has_electronic() const {
  return _internal_has_electronic();
}
inline const ::speech::sparrowhawk::Electronic& Token::_internal_electronic() const {
  const ::speech::sparrowhawk::Electronic* p = electronic_;
  return p != nullptr ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Electronic*>(
      &::speech::sparrowhawk::_Electronic_default_instance_);
}
inline const ::speech::sparrowhawk::Electronic& Token::electronic() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.electronic)
  return _internal_electronic();
}
inline ::speech::sparrowhawk::Electronic* Token::release_electronic() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.electronic)
  _has_bits_[0] &= ~0x00040000u;
  ::speech::sparrowhawk::Electronic* temp = electronic_;
  electronic_ = nullptr;
  return temp;
}
inline ::speech::sparrowhawk::Electronic* Token::_internal_mutable_electronic() {
  _has_bits_[0] |= 0x00040000u;
  if (electronic_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::sparrowhawk::Electronic>(GetArenaNoVirtual());
    electronic_ = p;
  }
  return electronic_;
}
inline ::speech::sparrowhawk::Electronic* Token::mutable_electronic() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.electronic)
  return _internal_mutable_electronic();
}
inline void Token::set_allocated_electronic(::speech::sparrowhawk::Electronic* electronic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(electronic_);
  }
  if (electronic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      electronic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, electronic, submessage_arena);
    }
    _has_bits_[0] |= 0x00040000u;
  } else {
    _has_bits_[0] &= ~0x00040000u;
  }
  electronic_ = electronic;
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.electronic)
}

// optional string verbatim = 26;
inline bool Token::_internal_has_verbatim() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Token::has_verbatim() const {
  return _internal_has_verbatim();
}
inline void Token::clear_verbatim() {
  verbatim_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& Token::verbatim() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.verbatim)
  return _internal_verbatim();
}
inline void Token::set_verbatim(const std::string& value) {
  _internal_set_verbatim(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.verbatim)
}
inline std::string* Token::mutable_verbatim() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.verbatim)
  return _internal_mutable_verbatim();
}
inline const std::string& Token::_internal_verbatim() const {
  return verbatim_.GetNoArena();
}
inline void Token::_internal_set_verbatim(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  verbatim_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Token::set_verbatim(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  verbatim_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Token.verbatim)
}
inline void Token::set_verbatim(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  verbatim_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Token.verbatim)
}
inline void Token::set_verbatim(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000020u;
  verbatim_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Token.verbatim)
}
inline std::string* Token::_internal_mutable_verbatim() {
  _has_bits_[0] |= 0x00000020u;
  return verbatim_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Token::release_verbatim() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.verbatim)
  if (!_internal_has_verbatim()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return verbatim_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_verbatim(std::string* verbatim) {
  if (verbatim != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  verbatim_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), verbatim);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.verbatim)
}

// optional string letters = 27;
inline bool Token::_internal_has_letters() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Token::has_letters() const {
  return _internal_has_letters();
}
inline void Token::clear_letters() {
  letters_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& Token::letters() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.letters)
  return _internal_letters();
}
inline void Token::set_letters(const std::string& value) {
  _internal_set_letters(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.letters)
}
inline std::string* Token::mutable_letters() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.letters)
  return _internal_mutable_letters();
}
inline const std::string& Token::_internal_letters() const {
  return letters_.GetNoArena();
}
inline void Token::_internal_set_letters(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  letters_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Token::set_letters(std::string&& value) {
  _has_bits_[0] |= 0x00000040u;
  letters_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Token.letters)
}
inline void Token::set_letters(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000040u;
  letters_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Token.letters)
}
inline void Token::set_letters(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000040u;
  letters_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Token.letters)
}
inline std::string* Token::_internal_mutable_letters() {
  _has_bits_[0] |= 0x00000040u;
  return letters_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Token::release_letters() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.letters)
  if (!_internal_has_letters()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return letters_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Token::set_allocated_letters(std::string* letters) {
  if (letters != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  letters_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), letters);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.letters)
}

// optional .speech.sparrowhawk.Connector connector = 28;
inline bool Token::_internal_has_connector() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  PROTOBUF_ASSUME(!value || connector_ != nullptr);
  return value;
}
inline bool Token::has_connector() const {
  return _internal_has_connector();
}
inline const ::speech::sparrowhawk::Connector& Token::_internal_connector() const {
  const ::speech::sparrowhawk::Connector* p = connector_;
  return p != nullptr ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Connector*>(
      &::speech::sparrowhawk::_Connector_default_instance_);
}
inline const ::speech::sparrowhawk::Connector& Token::connector() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.connector)
  return _internal_connector();
}
inline ::speech::sparrowhawk::Connector* Token::release_connector() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.connector)
  _has_bits_[0] &= ~0x00080000u;
  ::speech::sparrowhawk::Connector* temp = connector_;
  connector_ = nullptr;
  return temp;
}
inline ::speech::sparrowhawk::Connector* Token::_internal_mutable_connector() {
  _has_bits_[0] |= 0x00080000u;
  if (connector_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::sparrowhawk::Connector>(GetArenaNoVirtual());
    connector_ = p;
  }
  return connector_;
}
inline ::speech::sparrowhawk::Connector* Token::mutable_connector() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.connector)
  return _internal_mutable_connector();
}
inline void Token::set_allocated_connector(::speech::sparrowhawk::Connector* connector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(connector_);
  }
  if (connector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      connector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, connector, submessage_arena);
    }
    _has_bits_[0] |= 0x00080000u;
  } else {
    _has_bits_[0] &= ~0x00080000u;
  }
  connector_ = connector;
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.connector)
}

// optional .speech.sparrowhawk.Abbreviation abbreviation = 29;
inline bool Token::_internal_has_abbreviation() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  PROTOBUF_ASSUME(!value || abbreviation_ != nullptr);
  return value;
}
inline bool Token::has_abbreviation() const {
  return _internal_has_abbreviation();
}
inline const ::speech::sparrowhawk::Abbreviation& Token::_internal_abbreviation() const {
  const ::speech::sparrowhawk::Abbreviation* p = abbreviation_;
  return p != nullptr ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Abbreviation*>(
      &::speech::sparrowhawk::_Abbreviation_default_instance_);
}
inline const ::speech::sparrowhawk::Abbreviation& Token::abbreviation() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.abbreviation)
  return _internal_abbreviation();
}
inline ::speech::sparrowhawk::Abbreviation* Token::release_abbreviation() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Token.abbreviation)
  _has_bits_[0] &= ~0x00100000u;
  ::speech::sparrowhawk::Abbreviation* temp = abbreviation_;
  abbreviation_ = nullptr;
  return temp;
}
inline ::speech::sparrowhawk::Abbreviation* Token::_internal_mutable_abbreviation() {
  _has_bits_[0] |= 0x00100000u;
  if (abbreviation_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::sparrowhawk::Abbreviation>(GetArenaNoVirtual());
    abbreviation_ = p;
  }
  return abbreviation_;
}
inline ::speech::sparrowhawk::Abbreviation* Token::mutable_abbreviation() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Token.abbreviation)
  return _internal_mutable_abbreviation();
}
inline void Token::set_allocated_abbreviation(::speech::sparrowhawk::Abbreviation* abbreviation) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(abbreviation_);
  }
  if (abbreviation) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      abbreviation = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, abbreviation, submessage_arena);
    }
    _has_bits_[0] |= 0x00100000u;
  } else {
    _has_bits_[0] &= ~0x00100000u;
  }
  abbreviation_ = abbreviation;
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Token.abbreviation)
}

// optional int32 first_daughter = 30;
inline bool Token::_internal_has_first_daughter() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool Token::has_first_daughter() const {
  return _internal_has_first_daughter();
}
inline void Token::clear_first_daughter() {
  first_daughter_ = 0;
  _has_bits_[0] &= ~0x10000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Token::_internal_first_daughter() const {
  return first_daughter_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Token::first_daughter() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.first_daughter)
  return _internal_first_daughter();
}
inline void Token::_internal_set_first_daughter(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x10000000u;
  first_daughter_ = value;
}
inline void Token::set_first_daughter(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_first_daughter(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.first_daughter)
}

// optional int32 last_daughter = 31;
inline bool Token::_internal_has_last_daughter() const {
  bool value = (_has_bits_[0] & 0x20000000u) != 0;
  return value;
}
inline bool Token::has_last_daughter() const {
  return _internal_has_last_daughter();
}
inline void Token::clear_last_daughter() {
  last_daughter_ = 0;
  _has_bits_[0] &= ~0x20000000u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Token::_internal_last_daughter() const {
  return last_daughter_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Token::last_daughter() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Token.last_daughter)
  return _internal_last_daughter();
}
inline void Token::_internal_set_last_daughter(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x20000000u;
  last_daughter_ = value;
}
inline void Token::set_last_daughter(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_last_daughter(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Token.last_daughter)
}

// -------------------------------------------------------------------

// Word

// optional .speech.sparrowhawk.Links links = 1;
inline bool Word::_internal_has_links() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || links_ != nullptr);
  return value;
}
inline bool Word::has_links() const {
  return _internal_has_links();
}
inline const ::speech::sparrowhawk::Links& Word::_internal_links() const {
  const ::speech::sparrowhawk::Links* p = links_;
  return p != nullptr ? *p : *reinterpret_cast<const ::speech::sparrowhawk::Links*>(
      &::speech::sparrowhawk::_Links_default_instance_);
}
inline const ::speech::sparrowhawk::Links& Word::links() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Word.links)
  return _internal_links();
}
inline ::speech::sparrowhawk::Links* Word::release_links() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Word.links)
  _has_bits_[0] &= ~0x00000004u;
  ::speech::sparrowhawk::Links* temp = links_;
  links_ = nullptr;
  return temp;
}
inline ::speech::sparrowhawk::Links* Word::_internal_mutable_links() {
  _has_bits_[0] |= 0x00000004u;
  if (links_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::sparrowhawk::Links>(GetArenaNoVirtual());
    links_ = p;
  }
  return links_;
}
inline ::speech::sparrowhawk::Links* Word::mutable_links() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Word.links)
  return _internal_mutable_links();
}
inline void Word::set_allocated_links(::speech::sparrowhawk::Links* links) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(links_);
  }
  if (links) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      links = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, links, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  links_ = links;
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Word.links)
}

// optional string id = 2;
inline bool Word::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Word::has_id() const {
  return _internal_has_id();
}
inline void Word::clear_id() {
  id_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Word::id() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Word.id)
  return _internal_id();
}
inline void Word::set_id(const std::string& value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Word.id)
}
inline std::string* Word::mutable_id() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Word.id)
  return _internal_mutable_id();
}
inline const std::string& Word::_internal_id() const {
  return id_.GetNoArena();
}
inline void Word::_internal_set_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Word::set_id(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Word.id)
}
inline void Word::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Word.id)
}
inline void Word::set_id(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  id_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Word.id)
}
inline std::string* Word::_internal_mutable_id() {
  _has_bits_[0] |= 0x00000001u;
  return id_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Word::release_id() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Word.id)
  if (!_internal_has_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return id_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Word::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  id_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Word.id)
}

// optional string spelling = 3;
inline bool Word::_internal_has_spelling() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Word::has_spelling() const {
  return _internal_has_spelling();
}
inline void Word::clear_spelling() {
  spelling_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Word::spelling() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Word.spelling)
  return _internal_spelling();
}
inline void Word::set_spelling(const std::string& value) {
  _internal_set_spelling(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Word.spelling)
}
inline std::string* Word::mutable_spelling() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Word.spelling)
  return _internal_mutable_spelling();
}
inline const std::string& Word::_internal_spelling() const {
  return spelling_.GetNoArena();
}
inline void Word::_internal_set_spelling(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  spelling_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Word::set_spelling(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  spelling_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Word.spelling)
}
inline void Word::set_spelling(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  spelling_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Word.spelling)
}
inline void Word::set_spelling(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  spelling_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Word.spelling)
}
inline std::string* Word::_internal_mutable_spelling() {
  _has_bits_[0] |= 0x00000002u;
  return spelling_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Word::release_spelling() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Word.spelling)
  if (!_internal_has_spelling()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return spelling_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Word::set_allocated_spelling(std::string* spelling) {
  if (spelling != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  spelling_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), spelling);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Word.spelling)
}

// optional float pause_length = 4;
inline bool Word::_internal_has_pause_length() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Word::has_pause_length() const {
  return _internal_has_pause_length();
}
inline void Word::clear_pause_length() {
  pause_length_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float Word::_internal_pause_length() const {
  return pause_length_;
}
inline float Word::pause_length() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Word.pause_length)
  return _internal_pause_length();
}
inline void Word::_internal_set_pause_length(float value) {
  _has_bits_[0] |= 0x00000008u;
  pause_length_ = value;
}
inline void Word::set_pause_length(float value) {
  _internal_set_pause_length(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Word.pause_length)
}

// optional bool precedes_pause = 5;
inline bool Word::_internal_has_precedes_pause() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Word::has_precedes_pause() const {
  return _internal_has_precedes_pause();
}
inline void Word::clear_precedes_pause() {
  precedes_pause_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool Word::_internal_precedes_pause() const {
  return precedes_pause_;
}
inline bool Word::precedes_pause() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Word.precedes_pause)
  return _internal_precedes_pause();
}
inline void Word::_internal_set_precedes_pause(bool value) {
  _has_bits_[0] |= 0x00000010u;
  precedes_pause_ = value;
}
inline void Word::set_precedes_pause(bool value) {
  _internal_set_precedes_pause(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Word.precedes_pause)
}

// optional int32 parent = 6;
inline bool Word::_internal_has_parent() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Word::has_parent() const {
  return _internal_has_parent();
}
inline void Word::clear_parent() {
  parent_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Word::_internal_parent() const {
  return parent_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Word::parent() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Word.parent)
  return _internal_parent();
}
inline void Word::_internal_set_parent(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  parent_ = value;
}
inline void Word::set_parent(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_parent(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Word.parent)
}

// -------------------------------------------------------------------

// LinguisticStructure

// optional int64 id = 1;
inline bool LinguisticStructure::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool LinguisticStructure::has_id() const {
  return _internal_has_id();
}
inline void LinguisticStructure::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LinguisticStructure::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 LinguisticStructure::id() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.LinguisticStructure.id)
  return _internal_id();
}
inline void LinguisticStructure::_internal_set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000002u;
  id_ = value;
}
inline void LinguisticStructure::set_id(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.LinguisticStructure.id)
}

// optional string input = 2;
inline bool LinguisticStructure::_internal_has_input() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool LinguisticStructure::has_input() const {
  return _internal_has_input();
}
inline void LinguisticStructure::clear_input() {
  input_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& LinguisticStructure::input() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.LinguisticStructure.input)
  return _internal_input();
}
inline void LinguisticStructure::set_input(const std::string& value) {
  _internal_set_input(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.LinguisticStructure.input)
}
inline std::string* LinguisticStructure::mutable_input() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.LinguisticStructure.input)
  return _internal_mutable_input();
}
inline const std::string& LinguisticStructure::_internal_input() const {
  return input_.GetNoArena();
}
inline void LinguisticStructure::_internal_set_input(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  input_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void LinguisticStructure::set_input(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  input_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.LinguisticStructure.input)
}
inline void LinguisticStructure::set_input(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  input_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.LinguisticStructure.input)
}
inline void LinguisticStructure::set_input(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  input_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.LinguisticStructure.input)
}
inline std::string* LinguisticStructure::_internal_mutable_input() {
  _has_bits_[0] |= 0x00000001u;
  return input_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* LinguisticStructure::release_input() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.LinguisticStructure.input)
  if (!_internal_has_input()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return input_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void LinguisticStructure::set_allocated_input(std::string* input) {
  if (input != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  input_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), input);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.LinguisticStructure.input)
}

// repeated .speech.sparrowhawk.Token tokens = 3;
inline int LinguisticStructure::_internal_tokens_size() const {
  return tokens_.size();
}
inline int LinguisticStructure::tokens_size() const {
  return _internal_tokens_size();
}
inline void LinguisticStructure::clear_tokens() {
  tokens_.Clear();
}
inline ::speech::sparrowhawk::Token* LinguisticStructure::mutable_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.LinguisticStructure.tokens)
  return tokens_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speech::sparrowhawk::Token >*
LinguisticStructure::mutable_tokens() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.LinguisticStructure.tokens)
  return &tokens_;
}
inline const ::speech::sparrowhawk::Token& LinguisticStructure::_internal_tokens(int index) const {
  return tokens_.Get(index);
}
inline const ::speech::sparrowhawk::Token& LinguisticStructure::tokens(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.LinguisticStructure.tokens)
  return _internal_tokens(index);
}
inline ::speech::sparrowhawk::Token* LinguisticStructure::_internal_add_tokens() {
  return tokens_.Add();
}
inline ::speech::sparrowhawk::Token* LinguisticStructure::add_tokens() {
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.LinguisticStructure.tokens)
  return _internal_add_tokens();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speech::sparrowhawk::Token >&
LinguisticStructure::tokens() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.LinguisticStructure.tokens)
  return tokens_;
}

// repeated .speech.sparrowhawk.Word words = 4;
inline int LinguisticStructure::_internal_words_size() const {
  return words_.size();
}
inline int LinguisticStructure::words_size() const {
  return _internal_words_size();
}
inline void LinguisticStructure::clear_words() {
  words_.Clear();
}
inline ::speech::sparrowhawk::Word* LinguisticStructure::mutable_words(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.LinguisticStructure.words)
  return words_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speech::sparrowhawk::Word >*
LinguisticStructure::mutable_words() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.LinguisticStructure.words)
  return &words_;
}
inline const ::speech::sparrowhawk::Word& LinguisticStructure::_internal_words(int index) const {
  return words_.Get(index);
}
inline const ::speech::sparrowhawk::Word& LinguisticStructure::words(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.LinguisticStructure.words)
  return _internal_words(index);
}
inline ::speech::sparrowhawk::Word* LinguisticStructure::_internal_add_words() {
  return words_.Add();
}
inline ::speech::sparrowhawk::Word* LinguisticStructure::add_words() {
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.LinguisticStructure.words)
  return _internal_add_words();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::speech::sparrowhawk::Word >&
LinguisticStructure::words() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.LinguisticStructure.words)
  return words_;
}

// -------------------------------------------------------------------

// Utterance

// optional uint64 id = 1;
inline bool Utterance::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Utterance::has_id() const {
  return _internal_has_id();
}
inline void Utterance::clear_id() {
  id_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Utterance::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Utterance::id() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Utterance.id)
  return _internal_id();
}
inline void Utterance::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  id_ = value;
}
inline void Utterance::set_id(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Utterance.id)
}

// optional string filename = 2;
inline bool Utterance::_internal_has_filename() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Utterance::has_filename() const {
  return _internal_has_filename();
}
inline void Utterance::clear_filename() {
  filename_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Utterance::filename() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Utterance.filename)
  return _internal_filename();
}
inline void Utterance::set_filename(const std::string& value) {
  _internal_set_filename(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Utterance.filename)
}
inline std::string* Utterance::mutable_filename() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Utterance.filename)
  return _internal_mutable_filename();
}
inline const std::string& Utterance::_internal_filename() const {
  return filename_.GetNoArena();
}
inline void Utterance::_internal_set_filename(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Utterance::set_filename(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  filename_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Utterance.filename)
}
inline void Utterance::set_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Utterance.filename)
}
inline void Utterance::set_filename(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Utterance.filename)
}
inline std::string* Utterance::_internal_mutable_filename() {
  _has_bits_[0] |= 0x00000001u;
  return filename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Utterance::release_filename() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Utterance.filename)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return filename_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Utterance::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filename_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Utterance.filename)
}

// optional string sentence = 3;
inline bool Utterance::_internal_has_sentence() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Utterance::has_sentence() const {
  return _internal_has_sentence();
}
inline void Utterance::clear_sentence() {
  sentence_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Utterance::sentence() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Utterance.sentence)
  return _internal_sentence();
}
inline void Utterance::set_sentence(const std::string& value) {
  _internal_set_sentence(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Utterance.sentence)
}
inline std::string* Utterance::mutable_sentence() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Utterance.sentence)
  return _internal_mutable_sentence();
}
inline const std::string& Utterance::_internal_sentence() const {
  return sentence_.GetNoArena();
}
inline void Utterance::_internal_set_sentence(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  sentence_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Utterance::set_sentence(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  sentence_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Utterance.sentence)
}
inline void Utterance::set_sentence(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  sentence_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Utterance.sentence)
}
inline void Utterance::set_sentence(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  sentence_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Utterance.sentence)
}
inline std::string* Utterance::_internal_mutable_sentence() {
  _has_bits_[0] |= 0x00000002u;
  return sentence_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Utterance::release_sentence() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Utterance.sentence)
  if (!_internal_has_sentence()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return sentence_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Utterance::set_allocated_sentence(std::string* sentence) {
  if (sentence != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  sentence_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sentence);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Utterance.sentence)
}

// optional string original_sentence = 4;
inline bool Utterance::_internal_has_original_sentence() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Utterance::has_original_sentence() const {
  return _internal_has_original_sentence();
}
inline void Utterance::clear_original_sentence() {
  original_sentence_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Utterance::original_sentence() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Utterance.original_sentence)
  return _internal_original_sentence();
}
inline void Utterance::set_original_sentence(const std::string& value) {
  _internal_set_original_sentence(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Utterance.original_sentence)
}
inline std::string* Utterance::mutable_original_sentence() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Utterance.original_sentence)
  return _internal_mutable_original_sentence();
}
inline const std::string& Utterance::_internal_original_sentence() const {
  return original_sentence_.GetNoArena();
}
inline void Utterance::_internal_set_original_sentence(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  original_sentence_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void Utterance::set_original_sentence(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  original_sentence_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Utterance.original_sentence)
}
inline void Utterance::set_original_sentence(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  original_sentence_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Utterance.original_sentence)
}
inline void Utterance::set_original_sentence(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  original_sentence_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Utterance.original_sentence)
}
inline std::string* Utterance::_internal_mutable_original_sentence() {
  _has_bits_[0] |= 0x00000004u;
  return original_sentence_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* Utterance::release_original_sentence() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Utterance.original_sentence)
  if (!_internal_has_original_sentence()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return original_sentence_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void Utterance::set_allocated_original_sentence(std::string* original_sentence) {
  if (original_sentence != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  original_sentence_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), original_sentence);
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Utterance.original_sentence)
}

// repeated string segmenter_output = 5;
inline int Utterance::_internal_segmenter_output_size() const {
  return segmenter_output_.size();
}
inline int Utterance::segmenter_output_size() const {
  return _internal_segmenter_output_size();
}
inline void Utterance::clear_segmenter_output() {
  segmenter_output_.Clear();
}
inline std::string* Utterance::add_segmenter_output() {
  // @@protoc_insertion_point(field_add_mutable:speech.sparrowhawk.Utterance.segmenter_output)
  return _internal_add_segmenter_output();
}
inline const std::string& Utterance::_internal_segmenter_output(int index) const {
  return segmenter_output_.Get(index);
}
inline const std::string& Utterance::segmenter_output(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Utterance.segmenter_output)
  return _internal_segmenter_output(index);
}
inline std::string* Utterance::mutable_segmenter_output(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Utterance.segmenter_output)
  return segmenter_output_.Mutable(index);
}
inline void Utterance::set_segmenter_output(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Utterance.segmenter_output)
  segmenter_output_.Mutable(index)->assign(value);
}
inline void Utterance::set_segmenter_output(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Utterance.segmenter_output)
  segmenter_output_.Mutable(index)->assign(std::move(value));
}
inline void Utterance::set_segmenter_output(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  segmenter_output_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Utterance.segmenter_output)
}
inline void Utterance::set_segmenter_output(int index, const char* value, size_t size) {
  segmenter_output_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Utterance.segmenter_output)
}
inline std::string* Utterance::_internal_add_segmenter_output() {
  return segmenter_output_.Add();
}
inline void Utterance::add_segmenter_output(const std::string& value) {
  segmenter_output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Utterance.segmenter_output)
}
inline void Utterance::add_segmenter_output(std::string&& value) {
  segmenter_output_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Utterance.segmenter_output)
}
inline void Utterance::add_segmenter_output(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  segmenter_output_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.sparrowhawk.Utterance.segmenter_output)
}
inline void Utterance::add_segmenter_output(const char* value, size_t size) {
  segmenter_output_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.sparrowhawk.Utterance.segmenter_output)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Utterance::segmenter_output() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.Utterance.segmenter_output)
  return segmenter_output_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Utterance::mutable_segmenter_output() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.Utterance.segmenter_output)
  return &segmenter_output_;
}

// optional .speech.sparrowhawk.LinguisticStructure linguistic = 6;
inline bool Utterance::_internal_has_linguistic() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || linguistic_ != nullptr);
  return value;
}
inline bool Utterance::has_linguistic() const {
  return _internal_has_linguistic();
}
inline void Utterance::clear_linguistic() {
  if (linguistic_ != nullptr) linguistic_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::speech::sparrowhawk::LinguisticStructure& Utterance::_internal_linguistic() const {
  const ::speech::sparrowhawk::LinguisticStructure* p = linguistic_;
  return p != nullptr ? *p : *reinterpret_cast<const ::speech::sparrowhawk::LinguisticStructure*>(
      &::speech::sparrowhawk::_LinguisticStructure_default_instance_);
}
inline const ::speech::sparrowhawk::LinguisticStructure& Utterance::linguistic() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Utterance.linguistic)
  return _internal_linguistic();
}
inline ::speech::sparrowhawk::LinguisticStructure* Utterance::release_linguistic() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Utterance.linguistic)
  _has_bits_[0] &= ~0x00000008u;
  ::speech::sparrowhawk::LinguisticStructure* temp = linguistic_;
  linguistic_ = nullptr;
  return temp;
}
inline ::speech::sparrowhawk::LinguisticStructure* Utterance::_internal_mutable_linguistic() {
  _has_bits_[0] |= 0x00000008u;
  if (linguistic_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::sparrowhawk::LinguisticStructure>(GetArenaNoVirtual());
    linguistic_ = p;
  }
  return linguistic_;
}
inline ::speech::sparrowhawk::LinguisticStructure* Utterance::mutable_linguistic() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Utterance.linguistic)
  return _internal_mutable_linguistic();
}
inline void Utterance::set_allocated_linguistic(::speech::sparrowhawk::LinguisticStructure* linguistic) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete linguistic_;
  }
  if (linguistic) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      linguistic = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, linguistic, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  linguistic_ = linguistic;
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Utterance.linguistic)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sparrowhawk
}  // namespace speech

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::speech::sparrowhawk::Token_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::speech::sparrowhawk::Token_Type>() {
  return ::speech::sparrowhawk::Token_Type_descriptor();
}
template <> struct is_proto_enum< ::speech::sparrowhawk::Token_PauseLength> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::speech::sparrowhawk::Token_PauseLength>() {
  return ::speech::sparrowhawk::Token_PauseLength_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_items_2eproto
