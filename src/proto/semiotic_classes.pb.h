// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: semiotic_classes.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_semiotic_5fclasses_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_semiotic_5fclasses_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3014000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3014000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_semiotic_5fclasses_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_semiotic_5fclasses_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[12]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_semiotic_5fclasses_2eproto;
namespace speech {
namespace sparrowhawk {
class Abbreviation;
class AbbreviationDefaultTypeInternal;
extern AbbreviationDefaultTypeInternal _Abbreviation_default_instance_;
class Cardinal;
class CardinalDefaultTypeInternal;
extern CardinalDefaultTypeInternal _Cardinal_default_instance_;
class Connector;
class ConnectorDefaultTypeInternal;
extern ConnectorDefaultTypeInternal _Connector_default_instance_;
class Date;
class DateDefaultTypeInternal;
extern DateDefaultTypeInternal _Date_default_instance_;
class Decimal;
class DecimalDefaultTypeInternal;
extern DecimalDefaultTypeInternal _Decimal_default_instance_;
class Electronic;
class ElectronicDefaultTypeInternal;
extern ElectronicDefaultTypeInternal _Electronic_default_instance_;
class Fraction;
class FractionDefaultTypeInternal;
extern FractionDefaultTypeInternal _Fraction_default_instance_;
class Measure;
class MeasureDefaultTypeInternal;
extern MeasureDefaultTypeInternal _Measure_default_instance_;
class Money;
class MoneyDefaultTypeInternal;
extern MoneyDefaultTypeInternal _Money_default_instance_;
class Ordinal;
class OrdinalDefaultTypeInternal;
extern OrdinalDefaultTypeInternal _Ordinal_default_instance_;
class Telephone;
class TelephoneDefaultTypeInternal;
extern TelephoneDefaultTypeInternal _Telephone_default_instance_;
class Time;
class TimeDefaultTypeInternal;
extern TimeDefaultTypeInternal _Time_default_instance_;
}  // namespace sparrowhawk
}  // namespace speech
PROTOBUF_NAMESPACE_OPEN
template<> ::speech::sparrowhawk::Abbreviation* Arena::CreateMaybeMessage<::speech::sparrowhawk::Abbreviation>(Arena*);
template<> ::speech::sparrowhawk::Cardinal* Arena::CreateMaybeMessage<::speech::sparrowhawk::Cardinal>(Arena*);
template<> ::speech::sparrowhawk::Connector* Arena::CreateMaybeMessage<::speech::sparrowhawk::Connector>(Arena*);
template<> ::speech::sparrowhawk::Date* Arena::CreateMaybeMessage<::speech::sparrowhawk::Date>(Arena*);
template<> ::speech::sparrowhawk::Decimal* Arena::CreateMaybeMessage<::speech::sparrowhawk::Decimal>(Arena*);
template<> ::speech::sparrowhawk::Electronic* Arena::CreateMaybeMessage<::speech::sparrowhawk::Electronic>(Arena*);
template<> ::speech::sparrowhawk::Fraction* Arena::CreateMaybeMessage<::speech::sparrowhawk::Fraction>(Arena*);
template<> ::speech::sparrowhawk::Measure* Arena::CreateMaybeMessage<::speech::sparrowhawk::Measure>(Arena*);
template<> ::speech::sparrowhawk::Money* Arena::CreateMaybeMessage<::speech::sparrowhawk::Money>(Arena*);
template<> ::speech::sparrowhawk::Ordinal* Arena::CreateMaybeMessage<::speech::sparrowhawk::Ordinal>(Arena*);
template<> ::speech::sparrowhawk::Telephone* Arena::CreateMaybeMessage<::speech::sparrowhawk::Telephone>(Arena*);
template<> ::speech::sparrowhawk::Time* Arena::CreateMaybeMessage<::speech::sparrowhawk::Time>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace speech {
namespace sparrowhawk {

// ===================================================================

class Cardinal PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Cardinal) */ {
 public:
  inline Cardinal() : Cardinal(nullptr) {}
  virtual ~Cardinal();

  Cardinal(const Cardinal& from);
  Cardinal(Cardinal&& from) noexcept
    : Cardinal() {
    *this = ::std::move(from);
  }

  inline Cardinal& operator=(const Cardinal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Cardinal& operator=(Cardinal&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Cardinal& default_instance();

  static inline const Cardinal* internal_default_instance() {
    return reinterpret_cast<const Cardinal*>(
               &_Cardinal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Cardinal& a, Cardinal& b) {
    a.Swap(&b);
  }
  inline void Swap(Cardinal* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Cardinal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Cardinal* New() const final {
    return CreateMaybeMessage<Cardinal>(nullptr);
  }

  Cardinal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Cardinal>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Cardinal& from);
  void MergeFrom(const Cardinal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Cardinal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.sparrowhawk.Cardinal";
  }
  protected:
  explicit Cardinal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_semiotic_5fclasses_2eproto);
    return ::descriptor_table_semiotic_5fclasses_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldOrderFieldNumber = 5,
    kIntegerFieldNumber = 1,
    kMorphosyntacticFeaturesFieldNumber = 2,
    kCodeSwitchFieldNumber = 4,
    kPreserveOrderFieldNumber = 3,
  };
  // repeated string field_order = 5;
  int field_order_size() const;
  private:
  int _internal_field_order_size() const;
  public:
  void clear_field_order();
  const std::string& field_order(int index) const;
  std::string* mutable_field_order(int index);
  void set_field_order(int index, const std::string& value);
  void set_field_order(int index, std::string&& value);
  void set_field_order(int index, const char* value);
  void set_field_order(int index, const char* value, size_t size);
  std::string* add_field_order();
  void add_field_order(const std::string& value);
  void add_field_order(std::string&& value);
  void add_field_order(const char* value);
  void add_field_order(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& field_order() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_field_order();
  private:
  const std::string& _internal_field_order(int index) const;
  std::string* _internal_add_field_order();
  public:

  // required string integer = 1;
  bool has_integer() const;
  private:
  bool _internal_has_integer() const;
  public:
  void clear_integer();
  const std::string& integer() const;
  void set_integer(const std::string& value);
  void set_integer(std::string&& value);
  void set_integer(const char* value);
  void set_integer(const char* value, size_t size);
  std::string* mutable_integer();
  std::string* release_integer();
  void set_allocated_integer(std::string* integer);
  private:
  const std::string& _internal_integer() const;
  void _internal_set_integer(const std::string& value);
  std::string* _internal_mutable_integer();
  public:

  // optional string morphosyntactic_features = 2;
  bool has_morphosyntactic_features() const;
  private:
  bool _internal_has_morphosyntactic_features() const;
  public:
  void clear_morphosyntactic_features();
  const std::string& morphosyntactic_features() const;
  void set_morphosyntactic_features(const std::string& value);
  void set_morphosyntactic_features(std::string&& value);
  void set_morphosyntactic_features(const char* value);
  void set_morphosyntactic_features(const char* value, size_t size);
  std::string* mutable_morphosyntactic_features();
  std::string* release_morphosyntactic_features();
  void set_allocated_morphosyntactic_features(std::string* morphosyntactic_features);
  private:
  const std::string& _internal_morphosyntactic_features() const;
  void _internal_set_morphosyntactic_features(const std::string& value);
  std::string* _internal_mutable_morphosyntactic_features();
  public:

  // optional string code_switch = 4;
  bool has_code_switch() const;
  private:
  bool _internal_has_code_switch() const;
  public:
  void clear_code_switch();
  const std::string& code_switch() const;
  void set_code_switch(const std::string& value);
  void set_code_switch(std::string&& value);
  void set_code_switch(const char* value);
  void set_code_switch(const char* value, size_t size);
  std::string* mutable_code_switch();
  std::string* release_code_switch();
  void set_allocated_code_switch(std::string* code_switch);
  private:
  const std::string& _internal_code_switch() const;
  void _internal_set_code_switch(const std::string& value);
  std::string* _internal_mutable_code_switch();
  public:

  // optional bool preserve_order = 3;
  bool has_preserve_order() const;
  private:
  bool _internal_has_preserve_order() const;
  public:
  void clear_preserve_order();
  bool preserve_order() const;
  void set_preserve_order(bool value);
  private:
  bool _internal_preserve_order() const;
  void _internal_set_preserve_order(bool value);
  public:

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Cardinal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> field_order_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr integer_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr morphosyntactic_features_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_switch_;
  bool preserve_order_;
  friend struct ::TableStruct_semiotic_5fclasses_2eproto;
};
// -------------------------------------------------------------------

class Ordinal PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Ordinal) */ {
 public:
  inline Ordinal() : Ordinal(nullptr) {}
  virtual ~Ordinal();

  Ordinal(const Ordinal& from);
  Ordinal(Ordinal&& from) noexcept
    : Ordinal() {
    *this = ::std::move(from);
  }

  inline Ordinal& operator=(const Ordinal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Ordinal& operator=(Ordinal&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Ordinal& default_instance();

  static inline const Ordinal* internal_default_instance() {
    return reinterpret_cast<const Ordinal*>(
               &_Ordinal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(Ordinal& a, Ordinal& b) {
    a.Swap(&b);
  }
  inline void Swap(Ordinal* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Ordinal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Ordinal* New() const final {
    return CreateMaybeMessage<Ordinal>(nullptr);
  }

  Ordinal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Ordinal>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Ordinal& from);
  void MergeFrom(const Ordinal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Ordinal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.sparrowhawk.Ordinal";
  }
  protected:
  explicit Ordinal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_semiotic_5fclasses_2eproto);
    return ::descriptor_table_semiotic_5fclasses_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldOrderFieldNumber = 5,
    kIntegerFieldNumber = 1,
    kMorphosyntacticFeaturesFieldNumber = 2,
    kCodeSwitchFieldNumber = 4,
    kPreserveOrderFieldNumber = 3,
  };
  // repeated string field_order = 5;
  int field_order_size() const;
  private:
  int _internal_field_order_size() const;
  public:
  void clear_field_order();
  const std::string& field_order(int index) const;
  std::string* mutable_field_order(int index);
  void set_field_order(int index, const std::string& value);
  void set_field_order(int index, std::string&& value);
  void set_field_order(int index, const char* value);
  void set_field_order(int index, const char* value, size_t size);
  std::string* add_field_order();
  void add_field_order(const std::string& value);
  void add_field_order(std::string&& value);
  void add_field_order(const char* value);
  void add_field_order(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& field_order() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_field_order();
  private:
  const std::string& _internal_field_order(int index) const;
  std::string* _internal_add_field_order();
  public:

  // required string integer = 1;
  bool has_integer() const;
  private:
  bool _internal_has_integer() const;
  public:
  void clear_integer();
  const std::string& integer() const;
  void set_integer(const std::string& value);
  void set_integer(std::string&& value);
  void set_integer(const char* value);
  void set_integer(const char* value, size_t size);
  std::string* mutable_integer();
  std::string* release_integer();
  void set_allocated_integer(std::string* integer);
  private:
  const std::string& _internal_integer() const;
  void _internal_set_integer(const std::string& value);
  std::string* _internal_mutable_integer();
  public:

  // optional string morphosyntactic_features = 2;
  bool has_morphosyntactic_features() const;
  private:
  bool _internal_has_morphosyntactic_features() const;
  public:
  void clear_morphosyntactic_features();
  const std::string& morphosyntactic_features() const;
  void set_morphosyntactic_features(const std::string& value);
  void set_morphosyntactic_features(std::string&& value);
  void set_morphosyntactic_features(const char* value);
  void set_morphosyntactic_features(const char* value, size_t size);
  std::string* mutable_morphosyntactic_features();
  std::string* release_morphosyntactic_features();
  void set_allocated_morphosyntactic_features(std::string* morphosyntactic_features);
  private:
  const std::string& _internal_morphosyntactic_features() const;
  void _internal_set_morphosyntactic_features(const std::string& value);
  std::string* _internal_mutable_morphosyntactic_features();
  public:

  // optional string code_switch = 4;
  bool has_code_switch() const;
  private:
  bool _internal_has_code_switch() const;
  public:
  void clear_code_switch();
  const std::string& code_switch() const;
  void set_code_switch(const std::string& value);
  void set_code_switch(std::string&& value);
  void set_code_switch(const char* value);
  void set_code_switch(const char* value, size_t size);
  std::string* mutable_code_switch();
  std::string* release_code_switch();
  void set_allocated_code_switch(std::string* code_switch);
  private:
  const std::string& _internal_code_switch() const;
  void _internal_set_code_switch(const std::string& value);
  std::string* _internal_mutable_code_switch();
  public:

  // optional bool preserve_order = 3;
  bool has_preserve_order() const;
  private:
  bool _internal_has_preserve_order() const;
  public:
  void clear_preserve_order();
  bool preserve_order() const;
  void set_preserve_order(bool value);
  private:
  bool _internal_preserve_order() const;
  void _internal_set_preserve_order(bool value);
  public:

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Ordinal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> field_order_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr integer_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr morphosyntactic_features_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_switch_;
  bool preserve_order_;
  friend struct ::TableStruct_semiotic_5fclasses_2eproto;
};
// -------------------------------------------------------------------

class Fraction PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Fraction) */ {
 public:
  inline Fraction() : Fraction(nullptr) {}
  virtual ~Fraction();

  Fraction(const Fraction& from);
  Fraction(Fraction&& from) noexcept
    : Fraction() {
    *this = ::std::move(from);
  }

  inline Fraction& operator=(const Fraction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Fraction& operator=(Fraction&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Fraction& default_instance();

  static inline const Fraction* internal_default_instance() {
    return reinterpret_cast<const Fraction*>(
               &_Fraction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Fraction& a, Fraction& b) {
    a.Swap(&b);
  }
  inline void Swap(Fraction* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Fraction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Fraction* New() const final {
    return CreateMaybeMessage<Fraction>(nullptr);
  }

  Fraction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Fraction>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Fraction& from);
  void MergeFrom(const Fraction& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Fraction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.sparrowhawk.Fraction";
  }
  protected:
  explicit Fraction(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_semiotic_5fclasses_2eproto);
    return ::descriptor_table_semiotic_5fclasses_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldOrderFieldNumber = 9,
    kIntegerPartFieldNumber = 1,
    kNumeratorFieldNumber = 2,
    kDenominatorFieldNumber = 3,
    kMorphosyntacticFeaturesFieldNumber = 5,
    kCodeSwitchFieldNumber = 7,
    kStyleFieldNumber = 4,
    kPreserveOrderFieldNumber = 6,
    kNegativeFieldNumber = 8,
  };
  // repeated string field_order = 9;
  int field_order_size() const;
  private:
  int _internal_field_order_size() const;
  public:
  void clear_field_order();
  const std::string& field_order(int index) const;
  std::string* mutable_field_order(int index);
  void set_field_order(int index, const std::string& value);
  void set_field_order(int index, std::string&& value);
  void set_field_order(int index, const char* value);
  void set_field_order(int index, const char* value, size_t size);
  std::string* add_field_order();
  void add_field_order(const std::string& value);
  void add_field_order(std::string&& value);
  void add_field_order(const char* value);
  void add_field_order(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& field_order() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_field_order();
  private:
  const std::string& _internal_field_order(int index) const;
  std::string* _internal_add_field_order();
  public:

  // optional string integer_part = 1;
  bool has_integer_part() const;
  private:
  bool _internal_has_integer_part() const;
  public:
  void clear_integer_part();
  const std::string& integer_part() const;
  void set_integer_part(const std::string& value);
  void set_integer_part(std::string&& value);
  void set_integer_part(const char* value);
  void set_integer_part(const char* value, size_t size);
  std::string* mutable_integer_part();
  std::string* release_integer_part();
  void set_allocated_integer_part(std::string* integer_part);
  private:
  const std::string& _internal_integer_part() const;
  void _internal_set_integer_part(const std::string& value);
  std::string* _internal_mutable_integer_part();
  public:

  // required string numerator = 2;
  bool has_numerator() const;
  private:
  bool _internal_has_numerator() const;
  public:
  void clear_numerator();
  const std::string& numerator() const;
  void set_numerator(const std::string& value);
  void set_numerator(std::string&& value);
  void set_numerator(const char* value);
  void set_numerator(const char* value, size_t size);
  std::string* mutable_numerator();
  std::string* release_numerator();
  void set_allocated_numerator(std::string* numerator);
  private:
  const std::string& _internal_numerator() const;
  void _internal_set_numerator(const std::string& value);
  std::string* _internal_mutable_numerator();
  public:

  // required string denominator = 3;
  bool has_denominator() const;
  private:
  bool _internal_has_denominator() const;
  public:
  void clear_denominator();
  const std::string& denominator() const;
  void set_denominator(const std::string& value);
  void set_denominator(std::string&& value);
  void set_denominator(const char* value);
  void set_denominator(const char* value, size_t size);
  std::string* mutable_denominator();
  std::string* release_denominator();
  void set_allocated_denominator(std::string* denominator);
  private:
  const std::string& _internal_denominator() const;
  void _internal_set_denominator(const std::string& value);
  std::string* _internal_mutable_denominator();
  public:

  // optional string morphosyntactic_features = 5;
  bool has_morphosyntactic_features() const;
  private:
  bool _internal_has_morphosyntactic_features() const;
  public:
  void clear_morphosyntactic_features();
  const std::string& morphosyntactic_features() const;
  void set_morphosyntactic_features(const std::string& value);
  void set_morphosyntactic_features(std::string&& value);
  void set_morphosyntactic_features(const char* value);
  void set_morphosyntactic_features(const char* value, size_t size);
  std::string* mutable_morphosyntactic_features();
  std::string* release_morphosyntactic_features();
  void set_allocated_morphosyntactic_features(std::string* morphosyntactic_features);
  private:
  const std::string& _internal_morphosyntactic_features() const;
  void _internal_set_morphosyntactic_features(const std::string& value);
  std::string* _internal_mutable_morphosyntactic_features();
  public:

  // optional string code_switch = 7;
  bool has_code_switch() const;
  private:
  bool _internal_has_code_switch() const;
  public:
  void clear_code_switch();
  const std::string& code_switch() const;
  void set_code_switch(const std::string& value);
  void set_code_switch(std::string&& value);
  void set_code_switch(const char* value);
  void set_code_switch(const char* value, size_t size);
  std::string* mutable_code_switch();
  std::string* release_code_switch();
  void set_allocated_code_switch(std::string* code_switch);
  private:
  const std::string& _internal_code_switch() const;
  void _internal_set_code_switch(const std::string& value);
  std::string* _internal_mutable_code_switch();
  public:

  // optional int32 style = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_style() const;
  private:
  bool _internal_has_style() const;
  public:
  PROTOBUF_DEPRECATED void clear_style();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::int32 style() const;
  PROTOBUF_DEPRECATED void set_style(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_style() const;
  void _internal_set_style(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool preserve_order = 6;
  bool has_preserve_order() const;
  private:
  bool _internal_has_preserve_order() const;
  public:
  void clear_preserve_order();
  bool preserve_order() const;
  void set_preserve_order(bool value);
  private:
  bool _internal_preserve_order() const;
  void _internal_set_preserve_order(bool value);
  public:

  // optional bool negative = 8;
  bool has_negative() const;
  private:
  bool _internal_has_negative() const;
  public:
  void clear_negative();
  bool negative() const;
  void set_negative(bool value);
  private:
  bool _internal_negative() const;
  void _internal_set_negative(bool value);
  public:

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Fraction)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> field_order_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr integer_part_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr numerator_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr denominator_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr morphosyntactic_features_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_switch_;
  ::PROTOBUF_NAMESPACE_ID::int32 style_;
  bool preserve_order_;
  bool negative_;
  friend struct ::TableStruct_semiotic_5fclasses_2eproto;
};
// -------------------------------------------------------------------

class Time PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Time) */ {
 public:
  inline Time() : Time(nullptr) {}
  virtual ~Time();

  Time(const Time& from);
  Time(Time&& from) noexcept
    : Time() {
    *this = ::std::move(from);
  }

  inline Time& operator=(const Time& from) {
    CopyFrom(from);
    return *this;
  }
  inline Time& operator=(Time&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Time& default_instance();

  static inline const Time* internal_default_instance() {
    return reinterpret_cast<const Time*>(
               &_Time_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(Time& a, Time& b) {
    a.Swap(&b);
  }
  inline void Swap(Time* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Time* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Time* New() const final {
    return CreateMaybeMessage<Time>(nullptr);
  }

  Time* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Time>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Time& from);
  void MergeFrom(const Time& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Time* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.sparrowhawk.Time";
  }
  protected:
  explicit Time(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_semiotic_5fclasses_2eproto);
    return ::descriptor_table_semiotic_5fclasses_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldOrderFieldNumber = 12,
    kSuffixFieldNumber = 5,
    kZoneFieldNumber = 7,
    kMorphosyntacticFeaturesFieldNumber = 9,
    kCodeSwitchFieldNumber = 11,
    kHoursFieldNumber = 1,
    kMinutesFieldNumber = 2,
    kSecondsFieldNumber = 3,
    kStyleFieldNumber = 6,
    kSpeakPeriodFieldNumber = 4,
    kPreserveOrderFieldNumber = 10,
  };
  // repeated string field_order = 12;
  int field_order_size() const;
  private:
  int _internal_field_order_size() const;
  public:
  void clear_field_order();
  const std::string& field_order(int index) const;
  std::string* mutable_field_order(int index);
  void set_field_order(int index, const std::string& value);
  void set_field_order(int index, std::string&& value);
  void set_field_order(int index, const char* value);
  void set_field_order(int index, const char* value, size_t size);
  std::string* add_field_order();
  void add_field_order(const std::string& value);
  void add_field_order(std::string&& value);
  void add_field_order(const char* value);
  void add_field_order(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& field_order() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_field_order();
  private:
  const std::string& _internal_field_order(int index) const;
  std::string* _internal_add_field_order();
  public:

  // optional string suffix = 5 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_suffix() const;
  private:
  bool _internal_has_suffix() const;
  public:
  PROTOBUF_DEPRECATED void clear_suffix();
  PROTOBUF_DEPRECATED const std::string& suffix() const;
  PROTOBUF_DEPRECATED void set_suffix(const std::string& value);
  PROTOBUF_DEPRECATED void set_suffix(std::string&& value);
  PROTOBUF_DEPRECATED void set_suffix(const char* value);
  PROTOBUF_DEPRECATED void set_suffix(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_suffix();
  PROTOBUF_DEPRECATED std::string* release_suffix();
  PROTOBUF_DEPRECATED void set_allocated_suffix(std::string* suffix);
  private:
  const std::string& _internal_suffix() const;
  void _internal_set_suffix(const std::string& value);
  std::string* _internal_mutable_suffix();
  public:

  // optional string zone = 7;
  bool has_zone() const;
  private:
  bool _internal_has_zone() const;
  public:
  void clear_zone();
  const std::string& zone() const;
  void set_zone(const std::string& value);
  void set_zone(std::string&& value);
  void set_zone(const char* value);
  void set_zone(const char* value, size_t size);
  std::string* mutable_zone();
  std::string* release_zone();
  void set_allocated_zone(std::string* zone);
  private:
  const std::string& _internal_zone() const;
  void _internal_set_zone(const std::string& value);
  std::string* _internal_mutable_zone();
  public:

  // optional string morphosyntactic_features = 9;
  bool has_morphosyntactic_features() const;
  private:
  bool _internal_has_morphosyntactic_features() const;
  public:
  void clear_morphosyntactic_features();
  const std::string& morphosyntactic_features() const;
  void set_morphosyntactic_features(const std::string& value);
  void set_morphosyntactic_features(std::string&& value);
  void set_morphosyntactic_features(const char* value);
  void set_morphosyntactic_features(const char* value, size_t size);
  std::string* mutable_morphosyntactic_features();
  std::string* release_morphosyntactic_features();
  void set_allocated_morphosyntactic_features(std::string* morphosyntactic_features);
  private:
  const std::string& _internal_morphosyntactic_features() const;
  void _internal_set_morphosyntactic_features(const std::string& value);
  std::string* _internal_mutable_morphosyntactic_features();
  public:

  // optional string code_switch = 11;
  bool has_code_switch() const;
  private:
  bool _internal_has_code_switch() const;
  public:
  void clear_code_switch();
  const std::string& code_switch() const;
  void set_code_switch(const std::string& value);
  void set_code_switch(std::string&& value);
  void set_code_switch(const char* value);
  void set_code_switch(const char* value, size_t size);
  std::string* mutable_code_switch();
  std::string* release_code_switch();
  void set_allocated_code_switch(std::string* code_switch);
  private:
  const std::string& _internal_code_switch() const;
  void _internal_set_code_switch(const std::string& value);
  std::string* _internal_mutable_code_switch();
  public:

  // optional int32 hours = 1;
  bool has_hours() const;
  private:
  bool _internal_has_hours() const;
  public:
  void clear_hours();
  ::PROTOBUF_NAMESPACE_ID::int32 hours() const;
  void set_hours(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_hours() const;
  void _internal_set_hours(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 minutes = 2;
  bool has_minutes() const;
  private:
  bool _internal_has_minutes() const;
  public:
  void clear_minutes();
  ::PROTOBUF_NAMESPACE_ID::int32 minutes() const;
  void set_minutes(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_minutes() const;
  void _internal_set_minutes(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 seconds = 3 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_seconds() const;
  private:
  bool _internal_has_seconds() const;
  public:
  PROTOBUF_DEPRECATED void clear_seconds();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::int32 seconds() const;
  PROTOBUF_DEPRECATED void set_seconds(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_seconds() const;
  void _internal_set_seconds(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional int32 style = 6 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_style() const;
  private:
  bool _internal_has_style() const;
  public:
  PROTOBUF_DEPRECATED void clear_style();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::int32 style() const;
  PROTOBUF_DEPRECATED void set_style(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_style() const;
  void _internal_set_style(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool speak_period = 4;
  bool has_speak_period() const;
  private:
  bool _internal_has_speak_period() const;
  public:
  void clear_speak_period();
  bool speak_period() const;
  void set_speak_period(bool value);
  private:
  bool _internal_speak_period() const;
  void _internal_set_speak_period(bool value);
  public:

  // optional bool preserve_order = 10;
  bool has_preserve_order() const;
  private:
  bool _internal_has_preserve_order() const;
  public:
  void clear_preserve_order();
  bool preserve_order() const;
  void set_preserve_order(bool value);
  private:
  bool _internal_preserve_order() const;
  void _internal_set_preserve_order(bool value);
  public:

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Time)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> field_order_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr suffix_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr zone_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr morphosyntactic_features_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_switch_;
  ::PROTOBUF_NAMESPACE_ID::int32 hours_;
  ::PROTOBUF_NAMESPACE_ID::int32 minutes_;
  ::PROTOBUF_NAMESPACE_ID::int32 seconds_;
  ::PROTOBUF_NAMESPACE_ID::int32 style_;
  bool speak_period_;
  bool preserve_order_;
  friend struct ::TableStruct_semiotic_5fclasses_2eproto;
};
// -------------------------------------------------------------------

class Decimal PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Decimal) */ {
 public:
  inline Decimal() : Decimal(nullptr) {}
  virtual ~Decimal();

  Decimal(const Decimal& from);
  Decimal(Decimal&& from) noexcept
    : Decimal() {
    *this = ::std::move(from);
  }

  inline Decimal& operator=(const Decimal& from) {
    CopyFrom(from);
    return *this;
  }
  inline Decimal& operator=(Decimal&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Decimal& default_instance();

  static inline const Decimal* internal_default_instance() {
    return reinterpret_cast<const Decimal*>(
               &_Decimal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Decimal& a, Decimal& b) {
    a.Swap(&b);
  }
  inline void Swap(Decimal* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Decimal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Decimal* New() const final {
    return CreateMaybeMessage<Decimal>(nullptr);
  }

  Decimal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Decimal>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Decimal& from);
  void MergeFrom(const Decimal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Decimal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.sparrowhawk.Decimal";
  }
  protected:
  explicit Decimal(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_semiotic_5fclasses_2eproto);
    return ::descriptor_table_semiotic_5fclasses_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldOrderFieldNumber = 10,
    kIntegerPartFieldNumber = 2,
    kFractionalPartFieldNumber = 3,
    kQuantityFieldNumber = 4,
    kExponentFieldNumber = 5,
    kMorphosyntacticFeaturesFieldNumber = 7,
    kCodeSwitchFieldNumber = 9,
    kNegativeFieldNumber = 1,
    kPreserveOrderFieldNumber = 8,
    kStyleFieldNumber = 6,
  };
  // repeated string field_order = 10;
  int field_order_size() const;
  private:
  int _internal_field_order_size() const;
  public:
  void clear_field_order();
  const std::string& field_order(int index) const;
  std::string* mutable_field_order(int index);
  void set_field_order(int index, const std::string& value);
  void set_field_order(int index, std::string&& value);
  void set_field_order(int index, const char* value);
  void set_field_order(int index, const char* value, size_t size);
  std::string* add_field_order();
  void add_field_order(const std::string& value);
  void add_field_order(std::string&& value);
  void add_field_order(const char* value);
  void add_field_order(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& field_order() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_field_order();
  private:
  const std::string& _internal_field_order(int index) const;
  std::string* _internal_add_field_order();
  public:

  // optional string integer_part = 2;
  bool has_integer_part() const;
  private:
  bool _internal_has_integer_part() const;
  public:
  void clear_integer_part();
  const std::string& integer_part() const;
  void set_integer_part(const std::string& value);
  void set_integer_part(std::string&& value);
  void set_integer_part(const char* value);
  void set_integer_part(const char* value, size_t size);
  std::string* mutable_integer_part();
  std::string* release_integer_part();
  void set_allocated_integer_part(std::string* integer_part);
  private:
  const std::string& _internal_integer_part() const;
  void _internal_set_integer_part(const std::string& value);
  std::string* _internal_mutable_integer_part();
  public:

  // optional string fractional_part = 3;
  bool has_fractional_part() const;
  private:
  bool _internal_has_fractional_part() const;
  public:
  void clear_fractional_part();
  const std::string& fractional_part() const;
  void set_fractional_part(const std::string& value);
  void set_fractional_part(std::string&& value);
  void set_fractional_part(const char* value);
  void set_fractional_part(const char* value, size_t size);
  std::string* mutable_fractional_part();
  std::string* release_fractional_part();
  void set_allocated_fractional_part(std::string* fractional_part);
  private:
  const std::string& _internal_fractional_part() const;
  void _internal_set_fractional_part(const std::string& value);
  std::string* _internal_mutable_fractional_part();
  public:

  // optional string quantity = 4;
  bool has_quantity() const;
  private:
  bool _internal_has_quantity() const;
  public:
  void clear_quantity();
  const std::string& quantity() const;
  void set_quantity(const std::string& value);
  void set_quantity(std::string&& value);
  void set_quantity(const char* value);
  void set_quantity(const char* value, size_t size);
  std::string* mutable_quantity();
  std::string* release_quantity();
  void set_allocated_quantity(std::string* quantity);
  private:
  const std::string& _internal_quantity() const;
  void _internal_set_quantity(const std::string& value);
  std::string* _internal_mutable_quantity();
  public:

  // optional string exponent = 5;
  bool has_exponent() const;
  private:
  bool _internal_has_exponent() const;
  public:
  void clear_exponent();
  const std::string& exponent() const;
  void set_exponent(const std::string& value);
  void set_exponent(std::string&& value);
  void set_exponent(const char* value);
  void set_exponent(const char* value, size_t size);
  std::string* mutable_exponent();
  std::string* release_exponent();
  void set_allocated_exponent(std::string* exponent);
  private:
  const std::string& _internal_exponent() const;
  void _internal_set_exponent(const std::string& value);
  std::string* _internal_mutable_exponent();
  public:

  // optional string morphosyntactic_features = 7;
  bool has_morphosyntactic_features() const;
  private:
  bool _internal_has_morphosyntactic_features() const;
  public:
  void clear_morphosyntactic_features();
  const std::string& morphosyntactic_features() const;
  void set_morphosyntactic_features(const std::string& value);
  void set_morphosyntactic_features(std::string&& value);
  void set_morphosyntactic_features(const char* value);
  void set_morphosyntactic_features(const char* value, size_t size);
  std::string* mutable_morphosyntactic_features();
  std::string* release_morphosyntactic_features();
  void set_allocated_morphosyntactic_features(std::string* morphosyntactic_features);
  private:
  const std::string& _internal_morphosyntactic_features() const;
  void _internal_set_morphosyntactic_features(const std::string& value);
  std::string* _internal_mutable_morphosyntactic_features();
  public:

  // optional string code_switch = 9;
  bool has_code_switch() const;
  private:
  bool _internal_has_code_switch() const;
  public:
  void clear_code_switch();
  const std::string& code_switch() const;
  void set_code_switch(const std::string& value);
  void set_code_switch(std::string&& value);
  void set_code_switch(const char* value);
  void set_code_switch(const char* value, size_t size);
  std::string* mutable_code_switch();
  std::string* release_code_switch();
  void set_allocated_code_switch(std::string* code_switch);
  private:
  const std::string& _internal_code_switch() const;
  void _internal_set_code_switch(const std::string& value);
  std::string* _internal_mutable_code_switch();
  public:

  // optional bool negative = 1;
  bool has_negative() const;
  private:
  bool _internal_has_negative() const;
  public:
  void clear_negative();
  bool negative() const;
  void set_negative(bool value);
  private:
  bool _internal_negative() const;
  void _internal_set_negative(bool value);
  public:

  // optional bool preserve_order = 8;
  bool has_preserve_order() const;
  private:
  bool _internal_has_preserve_order() const;
  public:
  void clear_preserve_order();
  bool preserve_order() const;
  void set_preserve_order(bool value);
  private:
  bool _internal_preserve_order() const;
  void _internal_set_preserve_order(bool value);
  public:

  // optional int32 style = 6 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_style() const;
  private:
  bool _internal_has_style() const;
  public:
  PROTOBUF_DEPRECATED void clear_style();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::int32 style() const;
  PROTOBUF_DEPRECATED void set_style(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_style() const;
  void _internal_set_style(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Decimal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> field_order_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr integer_part_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fractional_part_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr quantity_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr exponent_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr morphosyntactic_features_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_switch_;
  bool negative_;
  bool preserve_order_;
  ::PROTOBUF_NAMESPACE_ID::int32 style_;
  friend struct ::TableStruct_semiotic_5fclasses_2eproto;
};
// -------------------------------------------------------------------

class Measure PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Measure) */ {
 public:
  inline Measure() : Measure(nullptr) {}
  virtual ~Measure();

  Measure(const Measure& from);
  Measure(Measure&& from) noexcept
    : Measure() {
    *this = ::std::move(from);
  }

  inline Measure& operator=(const Measure& from) {
    CopyFrom(from);
    return *this;
  }
  inline Measure& operator=(Measure&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Measure& default_instance();

  static inline const Measure* internal_default_instance() {
    return reinterpret_cast<const Measure*>(
               &_Measure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(Measure& a, Measure& b) {
    a.Swap(&b);
  }
  inline void Swap(Measure* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Measure* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Measure* New() const final {
    return CreateMaybeMessage<Measure>(nullptr);
  }

  Measure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Measure>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Measure& from);
  void MergeFrom(const Measure& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Measure* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.sparrowhawk.Measure";
  }
  protected:
  explicit Measure(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_semiotic_5fclasses_2eproto);
    return ::descriptor_table_semiotic_5fclasses_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldOrderFieldNumber = 9,
    kUnitsFieldNumber = 4,
    kMorphosyntacticFeaturesFieldNumber = 6,
    kCodeSwitchFieldNumber = 8,
    kDecimalFieldNumber = 1,
    kFractionFieldNumber = 2,
    kCardinalFieldNumber = 3,
    kStyleFieldNumber = 5,
    kPreserveOrderFieldNumber = 7,
  };
  // repeated string field_order = 9;
  int field_order_size() const;
  private:
  int _internal_field_order_size() const;
  public:
  void clear_field_order();
  const std::string& field_order(int index) const;
  std::string* mutable_field_order(int index);
  void set_field_order(int index, const std::string& value);
  void set_field_order(int index, std::string&& value);
  void set_field_order(int index, const char* value);
  void set_field_order(int index, const char* value, size_t size);
  std::string* add_field_order();
  void add_field_order(const std::string& value);
  void add_field_order(std::string&& value);
  void add_field_order(const char* value);
  void add_field_order(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& field_order() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_field_order();
  private:
  const std::string& _internal_field_order(int index) const;
  std::string* _internal_add_field_order();
  public:

  // optional string units = 4;
  bool has_units() const;
  private:
  bool _internal_has_units() const;
  public:
  void clear_units();
  const std::string& units() const;
  void set_units(const std::string& value);
  void set_units(std::string&& value);
  void set_units(const char* value);
  void set_units(const char* value, size_t size);
  std::string* mutable_units();
  std::string* release_units();
  void set_allocated_units(std::string* units);
  private:
  const std::string& _internal_units() const;
  void _internal_set_units(const std::string& value);
  std::string* _internal_mutable_units();
  public:

  // optional string morphosyntactic_features = 6;
  bool has_morphosyntactic_features() const;
  private:
  bool _internal_has_morphosyntactic_features() const;
  public:
  void clear_morphosyntactic_features();
  const std::string& morphosyntactic_features() const;
  void set_morphosyntactic_features(const std::string& value);
  void set_morphosyntactic_features(std::string&& value);
  void set_morphosyntactic_features(const char* value);
  void set_morphosyntactic_features(const char* value, size_t size);
  std::string* mutable_morphosyntactic_features();
  std::string* release_morphosyntactic_features();
  void set_allocated_morphosyntactic_features(std::string* morphosyntactic_features);
  private:
  const std::string& _internal_morphosyntactic_features() const;
  void _internal_set_morphosyntactic_features(const std::string& value);
  std::string* _internal_mutable_morphosyntactic_features();
  public:

  // optional string code_switch = 8;
  bool has_code_switch() const;
  private:
  bool _internal_has_code_switch() const;
  public:
  void clear_code_switch();
  const std::string& code_switch() const;
  void set_code_switch(const std::string& value);
  void set_code_switch(std::string&& value);
  void set_code_switch(const char* value);
  void set_code_switch(const char* value, size_t size);
  std::string* mutable_code_switch();
  std::string* release_code_switch();
  void set_allocated_code_switch(std::string* code_switch);
  private:
  const std::string& _internal_code_switch() const;
  void _internal_set_code_switch(const std::string& value);
  std::string* _internal_mutable_code_switch();
  public:

  // optional .speech.sparrowhawk.Decimal decimal = 1;
  bool has_decimal() const;
  private:
  bool _internal_has_decimal() const;
  public:
  void clear_decimal();
  const ::speech::sparrowhawk::Decimal& decimal() const;
  ::speech::sparrowhawk::Decimal* release_decimal();
  ::speech::sparrowhawk::Decimal* mutable_decimal();
  void set_allocated_decimal(::speech::sparrowhawk::Decimal* decimal);
  private:
  const ::speech::sparrowhawk::Decimal& _internal_decimal() const;
  ::speech::sparrowhawk::Decimal* _internal_mutable_decimal();
  public:
  void unsafe_arena_set_allocated_decimal(
      ::speech::sparrowhawk::Decimal* decimal);
  ::speech::sparrowhawk::Decimal* unsafe_arena_release_decimal();

  // optional .speech.sparrowhawk.Fraction fraction = 2;
  bool has_fraction() const;
  private:
  bool _internal_has_fraction() const;
  public:
  void clear_fraction();
  const ::speech::sparrowhawk::Fraction& fraction() const;
  ::speech::sparrowhawk::Fraction* release_fraction();
  ::speech::sparrowhawk::Fraction* mutable_fraction();
  void set_allocated_fraction(::speech::sparrowhawk::Fraction* fraction);
  private:
  const ::speech::sparrowhawk::Fraction& _internal_fraction() const;
  ::speech::sparrowhawk::Fraction* _internal_mutable_fraction();
  public:
  void unsafe_arena_set_allocated_fraction(
      ::speech::sparrowhawk::Fraction* fraction);
  ::speech::sparrowhawk::Fraction* unsafe_arena_release_fraction();

  // optional .speech.sparrowhawk.Cardinal cardinal = 3;
  bool has_cardinal() const;
  private:
  bool _internal_has_cardinal() const;
  public:
  void clear_cardinal();
  const ::speech::sparrowhawk::Cardinal& cardinal() const;
  ::speech::sparrowhawk::Cardinal* release_cardinal();
  ::speech::sparrowhawk::Cardinal* mutable_cardinal();
  void set_allocated_cardinal(::speech::sparrowhawk::Cardinal* cardinal);
  private:
  const ::speech::sparrowhawk::Cardinal& _internal_cardinal() const;
  ::speech::sparrowhawk::Cardinal* _internal_mutable_cardinal();
  public:
  void unsafe_arena_set_allocated_cardinal(
      ::speech::sparrowhawk::Cardinal* cardinal);
  ::speech::sparrowhawk::Cardinal* unsafe_arena_release_cardinal();

  // optional int32 style = 5 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_style() const;
  private:
  bool _internal_has_style() const;
  public:
  PROTOBUF_DEPRECATED void clear_style();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::int32 style() const;
  PROTOBUF_DEPRECATED void set_style(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_style() const;
  void _internal_set_style(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool preserve_order = 7;
  bool has_preserve_order() const;
  private:
  bool _internal_has_preserve_order() const;
  public:
  void clear_preserve_order();
  bool preserve_order() const;
  void set_preserve_order(bool value);
  private:
  bool _internal_preserve_order() const;
  void _internal_set_preserve_order(bool value);
  public:

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Measure)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> field_order_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr units_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr morphosyntactic_features_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_switch_;
  ::speech::sparrowhawk::Decimal* decimal_;
  ::speech::sparrowhawk::Fraction* fraction_;
  ::speech::sparrowhawk::Cardinal* cardinal_;
  ::PROTOBUF_NAMESPACE_ID::int32 style_;
  bool preserve_order_;
  friend struct ::TableStruct_semiotic_5fclasses_2eproto;
};
// -------------------------------------------------------------------

class Date PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Date) */ {
 public:
  inline Date() : Date(nullptr) {}
  virtual ~Date();

  Date(const Date& from);
  Date(Date&& from) noexcept
    : Date() {
    *this = ::std::move(from);
  }

  inline Date& operator=(const Date& from) {
    CopyFrom(from);
    return *this;
  }
  inline Date& operator=(Date&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Date& default_instance();

  static inline const Date* internal_default_instance() {
    return reinterpret_cast<const Date*>(
               &_Date_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Date& a, Date& b) {
    a.Swap(&b);
  }
  inline void Swap(Date* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Date* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Date* New() const final {
    return CreateMaybeMessage<Date>(nullptr);
  }

  Date* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Date>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Date& from);
  void MergeFrom(const Date& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Date* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.sparrowhawk.Date";
  }
  protected:
  explicit Date(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_semiotic_5fclasses_2eproto);
    return ::descriptor_table_semiotic_5fclasses_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldOrderFieldNumber = 12,
    kWeekdayFieldNumber = 1,
    kDayFieldNumber = 2,
    kMonthFieldNumber = 3,
    kYearFieldNumber = 4,
    kTextFieldNumber = 6,
    kEraFieldNumber = 8,
    kMorphosyntacticFeaturesFieldNumber = 9,
    kCodeSwitchFieldNumber = 11,
    kStyleFieldNumber = 5,
    kShortYearFieldNumber = 7,
    kPreserveOrderFieldNumber = 10,
  };
  // repeated string field_order = 12;
  int field_order_size() const;
  private:
  int _internal_field_order_size() const;
  public:
  void clear_field_order();
  const std::string& field_order(int index) const;
  std::string* mutable_field_order(int index);
  void set_field_order(int index, const std::string& value);
  void set_field_order(int index, std::string&& value);
  void set_field_order(int index, const char* value);
  void set_field_order(int index, const char* value, size_t size);
  std::string* add_field_order();
  void add_field_order(const std::string& value);
  void add_field_order(std::string&& value);
  void add_field_order(const char* value);
  void add_field_order(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& field_order() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_field_order();
  private:
  const std::string& _internal_field_order(int index) const;
  std::string* _internal_add_field_order();
  public:

  // optional string weekday = 1;
  bool has_weekday() const;
  private:
  bool _internal_has_weekday() const;
  public:
  void clear_weekday();
  const std::string& weekday() const;
  void set_weekday(const std::string& value);
  void set_weekday(std::string&& value);
  void set_weekday(const char* value);
  void set_weekday(const char* value, size_t size);
  std::string* mutable_weekday();
  std::string* release_weekday();
  void set_allocated_weekday(std::string* weekday);
  private:
  const std::string& _internal_weekday() const;
  void _internal_set_weekday(const std::string& value);
  std::string* _internal_mutable_weekday();
  public:

  // optional string day = 2;
  bool has_day() const;
  private:
  bool _internal_has_day() const;
  public:
  void clear_day();
  const std::string& day() const;
  void set_day(const std::string& value);
  void set_day(std::string&& value);
  void set_day(const char* value);
  void set_day(const char* value, size_t size);
  std::string* mutable_day();
  std::string* release_day();
  void set_allocated_day(std::string* day);
  private:
  const std::string& _internal_day() const;
  void _internal_set_day(const std::string& value);
  std::string* _internal_mutable_day();
  public:

  // optional string month = 3;
  bool has_month() const;
  private:
  bool _internal_has_month() const;
  public:
  void clear_month();
  const std::string& month() const;
  void set_month(const std::string& value);
  void set_month(std::string&& value);
  void set_month(const char* value);
  void set_month(const char* value, size_t size);
  std::string* mutable_month();
  std::string* release_month();
  void set_allocated_month(std::string* month);
  private:
  const std::string& _internal_month() const;
  void _internal_set_month(const std::string& value);
  std::string* _internal_mutable_month();
  public:

  // optional string year = 4;
  bool has_year() const;
  private:
  bool _internal_has_year() const;
  public:
  void clear_year();
  const std::string& year() const;
  void set_year(const std::string& value);
  void set_year(std::string&& value);
  void set_year(const char* value);
  void set_year(const char* value, size_t size);
  std::string* mutable_year();
  std::string* release_year();
  void set_allocated_year(std::string* year);
  private:
  const std::string& _internal_year() const;
  void _internal_set_year(const std::string& value);
  std::string* _internal_mutable_year();
  public:

  // optional string text = 6 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  PROTOBUF_DEPRECATED void clear_text();
  PROTOBUF_DEPRECATED const std::string& text() const;
  PROTOBUF_DEPRECATED void set_text(const std::string& value);
  PROTOBUF_DEPRECATED void set_text(std::string&& value);
  PROTOBUF_DEPRECATED void set_text(const char* value);
  PROTOBUF_DEPRECATED void set_text(const char* value, size_t size);
  PROTOBUF_DEPRECATED std::string* mutable_text();
  PROTOBUF_DEPRECATED std::string* release_text();
  PROTOBUF_DEPRECATED void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // optional string era = 8;
  bool has_era() const;
  private:
  bool _internal_has_era() const;
  public:
  void clear_era();
  const std::string& era() const;
  void set_era(const std::string& value);
  void set_era(std::string&& value);
  void set_era(const char* value);
  void set_era(const char* value, size_t size);
  std::string* mutable_era();
  std::string* release_era();
  void set_allocated_era(std::string* era);
  private:
  const std::string& _internal_era() const;
  void _internal_set_era(const std::string& value);
  std::string* _internal_mutable_era();
  public:

  // optional string morphosyntactic_features = 9;
  bool has_morphosyntactic_features() const;
  private:
  bool _internal_has_morphosyntactic_features() const;
  public:
  void clear_morphosyntactic_features();
  const std::string& morphosyntactic_features() const;
  void set_morphosyntactic_features(const std::string& value);
  void set_morphosyntactic_features(std::string&& value);
  void set_morphosyntactic_features(const char* value);
  void set_morphosyntactic_features(const char* value, size_t size);
  std::string* mutable_morphosyntactic_features();
  std::string* release_morphosyntactic_features();
  void set_allocated_morphosyntactic_features(std::string* morphosyntactic_features);
  private:
  const std::string& _internal_morphosyntactic_features() const;
  void _internal_set_morphosyntactic_features(const std::string& value);
  std::string* _internal_mutable_morphosyntactic_features();
  public:

  // optional string code_switch = 11;
  bool has_code_switch() const;
  private:
  bool _internal_has_code_switch() const;
  public:
  void clear_code_switch();
  const std::string& code_switch() const;
  void set_code_switch(const std::string& value);
  void set_code_switch(std::string&& value);
  void set_code_switch(const char* value);
  void set_code_switch(const char* value, size_t size);
  std::string* mutable_code_switch();
  std::string* release_code_switch();
  void set_allocated_code_switch(std::string* code_switch);
  private:
  const std::string& _internal_code_switch() const;
  void _internal_set_code_switch(const std::string& value);
  std::string* _internal_mutable_code_switch();
  public:

  // optional int32 style = 5 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_style() const;
  private:
  bool _internal_has_style() const;
  public:
  PROTOBUF_DEPRECATED void clear_style();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::int32 style() const;
  PROTOBUF_DEPRECATED void set_style(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_style() const;
  void _internal_set_style(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool short_year = 7 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_short_year() const;
  private:
  bool _internal_has_short_year() const;
  public:
  PROTOBUF_DEPRECATED void clear_short_year();
  PROTOBUF_DEPRECATED bool short_year() const;
  PROTOBUF_DEPRECATED void set_short_year(bool value);
  private:
  bool _internal_short_year() const;
  void _internal_set_short_year(bool value);
  public:

  // optional bool preserve_order = 10;
  bool has_preserve_order() const;
  private:
  bool _internal_has_preserve_order() const;
  public:
  void clear_preserve_order();
  bool preserve_order() const;
  void set_preserve_order(bool value);
  private:
  bool _internal_preserve_order() const;
  void _internal_set_preserve_order(bool value);
  public:

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Date)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> field_order_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr weekday_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr day_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr month_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr year_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr era_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr morphosyntactic_features_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_switch_;
  ::PROTOBUF_NAMESPACE_ID::int32 style_;
  bool short_year_;
  bool preserve_order_;
  friend struct ::TableStruct_semiotic_5fclasses_2eproto;
};
// -------------------------------------------------------------------

class Money PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Money) */ {
 public:
  inline Money() : Money(nullptr) {}
  virtual ~Money();

  Money(const Money& from);
  Money(Money&& from) noexcept
    : Money() {
    *this = ::std::move(from);
  }

  inline Money& operator=(const Money& from) {
    CopyFrom(from);
    return *this;
  }
  inline Money& operator=(Money&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Money& default_instance();

  static inline const Money* internal_default_instance() {
    return reinterpret_cast<const Money*>(
               &_Money_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(Money& a, Money& b) {
    a.Swap(&b);
  }
  inline void Swap(Money* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Money* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Money* New() const final {
    return CreateMaybeMessage<Money>(nullptr);
  }

  Money* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Money>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Money& from);
  void MergeFrom(const Money& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Money* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.sparrowhawk.Money";
  }
  protected:
  explicit Money(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_semiotic_5fclasses_2eproto);
    return ::descriptor_table_semiotic_5fclasses_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldOrderFieldNumber = 8,
    kCurrencyFieldNumber = 3,
    kMorphosyntacticFeaturesFieldNumber = 5,
    kCodeSwitchFieldNumber = 7,
    kAmountFieldNumber = 1,
    kQuantityFieldNumber = 2,
    kStyleFieldNumber = 4,
    kPreserveOrderFieldNumber = 6,
  };
  // repeated string field_order = 8;
  int field_order_size() const;
  private:
  int _internal_field_order_size() const;
  public:
  void clear_field_order();
  const std::string& field_order(int index) const;
  std::string* mutable_field_order(int index);
  void set_field_order(int index, const std::string& value);
  void set_field_order(int index, std::string&& value);
  void set_field_order(int index, const char* value);
  void set_field_order(int index, const char* value, size_t size);
  std::string* add_field_order();
  void add_field_order(const std::string& value);
  void add_field_order(std::string&& value);
  void add_field_order(const char* value);
  void add_field_order(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& field_order() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_field_order();
  private:
  const std::string& _internal_field_order(int index) const;
  std::string* _internal_add_field_order();
  public:

  // required string currency = 3;
  bool has_currency() const;
  private:
  bool _internal_has_currency() const;
  public:
  void clear_currency();
  const std::string& currency() const;
  void set_currency(const std::string& value);
  void set_currency(std::string&& value);
  void set_currency(const char* value);
  void set_currency(const char* value, size_t size);
  std::string* mutable_currency();
  std::string* release_currency();
  void set_allocated_currency(std::string* currency);
  private:
  const std::string& _internal_currency() const;
  void _internal_set_currency(const std::string& value);
  std::string* _internal_mutable_currency();
  public:

  // optional string morphosyntactic_features = 5;
  bool has_morphosyntactic_features() const;
  private:
  bool _internal_has_morphosyntactic_features() const;
  public:
  void clear_morphosyntactic_features();
  const std::string& morphosyntactic_features() const;
  void set_morphosyntactic_features(const std::string& value);
  void set_morphosyntactic_features(std::string&& value);
  void set_morphosyntactic_features(const char* value);
  void set_morphosyntactic_features(const char* value, size_t size);
  std::string* mutable_morphosyntactic_features();
  std::string* release_morphosyntactic_features();
  void set_allocated_morphosyntactic_features(std::string* morphosyntactic_features);
  private:
  const std::string& _internal_morphosyntactic_features() const;
  void _internal_set_morphosyntactic_features(const std::string& value);
  std::string* _internal_mutable_morphosyntactic_features();
  public:

  // optional string code_switch = 7;
  bool has_code_switch() const;
  private:
  bool _internal_has_code_switch() const;
  public:
  void clear_code_switch();
  const std::string& code_switch() const;
  void set_code_switch(const std::string& value);
  void set_code_switch(std::string&& value);
  void set_code_switch(const char* value);
  void set_code_switch(const char* value, size_t size);
  std::string* mutable_code_switch();
  std::string* release_code_switch();
  void set_allocated_code_switch(std::string* code_switch);
  private:
  const std::string& _internal_code_switch() const;
  void _internal_set_code_switch(const std::string& value);
  std::string* _internal_mutable_code_switch();
  public:

  // required .speech.sparrowhawk.Decimal amount = 1;
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  const ::speech::sparrowhawk::Decimal& amount() const;
  ::speech::sparrowhawk::Decimal* release_amount();
  ::speech::sparrowhawk::Decimal* mutable_amount();
  void set_allocated_amount(::speech::sparrowhawk::Decimal* amount);
  private:
  const ::speech::sparrowhawk::Decimal& _internal_amount() const;
  ::speech::sparrowhawk::Decimal* _internal_mutable_amount();
  public:
  void unsafe_arena_set_allocated_amount(
      ::speech::sparrowhawk::Decimal* amount);
  ::speech::sparrowhawk::Decimal* unsafe_arena_release_amount();

  // optional int64 quantity = 2;
  bool has_quantity() const;
  private:
  bool _internal_has_quantity() const;
  public:
  void clear_quantity();
  ::PROTOBUF_NAMESPACE_ID::int64 quantity() const;
  void set_quantity(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_quantity() const;
  void _internal_set_quantity(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // optional int32 style = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_style() const;
  private:
  bool _internal_has_style() const;
  public:
  PROTOBUF_DEPRECATED void clear_style();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::int32 style() const;
  PROTOBUF_DEPRECATED void set_style(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_style() const;
  void _internal_set_style(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool preserve_order = 6;
  bool has_preserve_order() const;
  private:
  bool _internal_has_preserve_order() const;
  public:
  void clear_preserve_order();
  bool preserve_order() const;
  void set_preserve_order(bool value);
  private:
  bool _internal_preserve_order() const;
  void _internal_set_preserve_order(bool value);
  public:

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Money)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> field_order_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr currency_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr morphosyntactic_features_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_switch_;
  ::speech::sparrowhawk::Decimal* amount_;
  ::PROTOBUF_NAMESPACE_ID::int64 quantity_;
  ::PROTOBUF_NAMESPACE_ID::int32 style_;
  bool preserve_order_;
  friend struct ::TableStruct_semiotic_5fclasses_2eproto;
};
// -------------------------------------------------------------------

class Telephone PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Telephone) */ {
 public:
  inline Telephone() : Telephone(nullptr) {}
  virtual ~Telephone();

  Telephone(const Telephone& from);
  Telephone(Telephone&& from) noexcept
    : Telephone() {
    *this = ::std::move(from);
  }

  inline Telephone& operator=(const Telephone& from) {
    CopyFrom(from);
    return *this;
  }
  inline Telephone& operator=(Telephone&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Telephone& default_instance();

  static inline const Telephone* internal_default_instance() {
    return reinterpret_cast<const Telephone*>(
               &_Telephone_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Telephone& a, Telephone& b) {
    a.Swap(&b);
  }
  inline void Swap(Telephone* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Telephone* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Telephone* New() const final {
    return CreateMaybeMessage<Telephone>(nullptr);
  }

  Telephone* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Telephone>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Telephone& from);
  void MergeFrom(const Telephone& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Telephone* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.sparrowhawk.Telephone";
  }
  protected:
  explicit Telephone(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_semiotic_5fclasses_2eproto);
    return ::descriptor_table_semiotic_5fclasses_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNumberPartFieldNumber = 2,
    kFieldOrderFieldNumber = 8,
    kCountryCodeFieldNumber = 1,
    kExtensionFieldNumber = 3,
    kMorphosyntacticFeaturesFieldNumber = 5,
    kCodeSwitchFieldNumber = 7,
    kStyleFieldNumber = 4,
    kPreserveOrderFieldNumber = 6,
  };
  // repeated string number_part = 2;
  int number_part_size() const;
  private:
  int _internal_number_part_size() const;
  public:
  void clear_number_part();
  const std::string& number_part(int index) const;
  std::string* mutable_number_part(int index);
  void set_number_part(int index, const std::string& value);
  void set_number_part(int index, std::string&& value);
  void set_number_part(int index, const char* value);
  void set_number_part(int index, const char* value, size_t size);
  std::string* add_number_part();
  void add_number_part(const std::string& value);
  void add_number_part(std::string&& value);
  void add_number_part(const char* value);
  void add_number_part(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& number_part() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_number_part();
  private:
  const std::string& _internal_number_part(int index) const;
  std::string* _internal_add_number_part();
  public:

  // repeated string field_order = 8;
  int field_order_size() const;
  private:
  int _internal_field_order_size() const;
  public:
  void clear_field_order();
  const std::string& field_order(int index) const;
  std::string* mutable_field_order(int index);
  void set_field_order(int index, const std::string& value);
  void set_field_order(int index, std::string&& value);
  void set_field_order(int index, const char* value);
  void set_field_order(int index, const char* value, size_t size);
  std::string* add_field_order();
  void add_field_order(const std::string& value);
  void add_field_order(std::string&& value);
  void add_field_order(const char* value);
  void add_field_order(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& field_order() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_field_order();
  private:
  const std::string& _internal_field_order(int index) const;
  std::string* _internal_add_field_order();
  public:

  // optional string country_code = 1;
  bool has_country_code() const;
  private:
  bool _internal_has_country_code() const;
  public:
  void clear_country_code();
  const std::string& country_code() const;
  void set_country_code(const std::string& value);
  void set_country_code(std::string&& value);
  void set_country_code(const char* value);
  void set_country_code(const char* value, size_t size);
  std::string* mutable_country_code();
  std::string* release_country_code();
  void set_allocated_country_code(std::string* country_code);
  private:
  const std::string& _internal_country_code() const;
  void _internal_set_country_code(const std::string& value);
  std::string* _internal_mutable_country_code();
  public:

  // optional string extension = 3;
  bool has_extension() const;
  private:
  bool _internal_has_extension() const;
  public:
  void clear_extension();
  const std::string& extension() const;
  void set_extension(const std::string& value);
  void set_extension(std::string&& value);
  void set_extension(const char* value);
  void set_extension(const char* value, size_t size);
  std::string* mutable_extension();
  std::string* release_extension();
  void set_allocated_extension(std::string* extension);
  private:
  const std::string& _internal_extension() const;
  void _internal_set_extension(const std::string& value);
  std::string* _internal_mutable_extension();
  public:

  // optional string morphosyntactic_features = 5;
  bool has_morphosyntactic_features() const;
  private:
  bool _internal_has_morphosyntactic_features() const;
  public:
  void clear_morphosyntactic_features();
  const std::string& morphosyntactic_features() const;
  void set_morphosyntactic_features(const std::string& value);
  void set_morphosyntactic_features(std::string&& value);
  void set_morphosyntactic_features(const char* value);
  void set_morphosyntactic_features(const char* value, size_t size);
  std::string* mutable_morphosyntactic_features();
  std::string* release_morphosyntactic_features();
  void set_allocated_morphosyntactic_features(std::string* morphosyntactic_features);
  private:
  const std::string& _internal_morphosyntactic_features() const;
  void _internal_set_morphosyntactic_features(const std::string& value);
  std::string* _internal_mutable_morphosyntactic_features();
  public:

  // optional string code_switch = 7;
  bool has_code_switch() const;
  private:
  bool _internal_has_code_switch() const;
  public:
  void clear_code_switch();
  const std::string& code_switch() const;
  void set_code_switch(const std::string& value);
  void set_code_switch(std::string&& value);
  void set_code_switch(const char* value);
  void set_code_switch(const char* value, size_t size);
  std::string* mutable_code_switch();
  std::string* release_code_switch();
  void set_allocated_code_switch(std::string* code_switch);
  private:
  const std::string& _internal_code_switch() const;
  void _internal_set_code_switch(const std::string& value);
  std::string* _internal_mutable_code_switch();
  public:

  // optional int32 style = 4 [deprecated = true];
  PROTOBUF_DEPRECATED bool has_style() const;
  private:
  bool _internal_has_style() const;
  public:
  PROTOBUF_DEPRECATED void clear_style();
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::int32 style() const;
  PROTOBUF_DEPRECATED void set_style(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_style() const;
  void _internal_set_style(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool preserve_order = 6;
  bool has_preserve_order() const;
  private:
  bool _internal_has_preserve_order() const;
  public:
  void clear_preserve_order();
  bool preserve_order() const;
  void set_preserve_order(bool value);
  private:
  bool _internal_preserve_order() const;
  void _internal_set_preserve_order(bool value);
  public:

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Telephone)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> number_part_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> field_order_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_code_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extension_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr morphosyntactic_features_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_switch_;
  ::PROTOBUF_NAMESPACE_ID::int32 style_;
  bool preserve_order_;
  friend struct ::TableStruct_semiotic_5fclasses_2eproto;
};
// -------------------------------------------------------------------

class Electronic PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Electronic) */ {
 public:
  inline Electronic() : Electronic(nullptr) {}
  virtual ~Electronic();

  Electronic(const Electronic& from);
  Electronic(Electronic&& from) noexcept
    : Electronic() {
    *this = ::std::move(from);
  }

  inline Electronic& operator=(const Electronic& from) {
    CopyFrom(from);
    return *this;
  }
  inline Electronic& operator=(Electronic&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Electronic& default_instance();

  static inline const Electronic* internal_default_instance() {
    return reinterpret_cast<const Electronic*>(
               &_Electronic_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Electronic& a, Electronic& b) {
    a.Swap(&b);
  }
  inline void Swap(Electronic* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Electronic* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Electronic* New() const final {
    return CreateMaybeMessage<Electronic>(nullptr);
  }

  Electronic* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Electronic>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Electronic& from);
  void MergeFrom(const Electronic& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Electronic* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.sparrowhawk.Electronic";
  }
  protected:
  explicit Electronic(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_semiotic_5fclasses_2eproto);
    return ::descriptor_table_semiotic_5fclasses_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFieldOrderFieldNumber = 12,
    kProtocolFieldNumber = 1,
    kUsernameFieldNumber = 2,
    kPasswordFieldNumber = 3,
    kDomainFieldNumber = 4,
    kPathFieldNumber = 6,
    kQueryStringFieldNumber = 7,
    kFragmentIdFieldNumber = 8,
    kMorphosyntacticFeaturesFieldNumber = 9,
    kCodeSwitchFieldNumber = 11,
    kPortFieldNumber = 5,
    kPreserveOrderFieldNumber = 10,
  };
  // repeated string field_order = 12;
  int field_order_size() const;
  private:
  int _internal_field_order_size() const;
  public:
  void clear_field_order();
  const std::string& field_order(int index) const;
  std::string* mutable_field_order(int index);
  void set_field_order(int index, const std::string& value);
  void set_field_order(int index, std::string&& value);
  void set_field_order(int index, const char* value);
  void set_field_order(int index, const char* value, size_t size);
  std::string* add_field_order();
  void add_field_order(const std::string& value);
  void add_field_order(std::string&& value);
  void add_field_order(const char* value);
  void add_field_order(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& field_order() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_field_order();
  private:
  const std::string& _internal_field_order(int index) const;
  std::string* _internal_add_field_order();
  public:

  // optional string protocol = 1;
  bool has_protocol() const;
  private:
  bool _internal_has_protocol() const;
  public:
  void clear_protocol();
  const std::string& protocol() const;
  void set_protocol(const std::string& value);
  void set_protocol(std::string&& value);
  void set_protocol(const char* value);
  void set_protocol(const char* value, size_t size);
  std::string* mutable_protocol();
  std::string* release_protocol();
  void set_allocated_protocol(std::string* protocol);
  private:
  const std::string& _internal_protocol() const;
  void _internal_set_protocol(const std::string& value);
  std::string* _internal_mutable_protocol();
  public:

  // optional string username = 2;
  bool has_username() const;
  private:
  bool _internal_has_username() const;
  public:
  void clear_username();
  const std::string& username() const;
  void set_username(const std::string& value);
  void set_username(std::string&& value);
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  std::string* mutable_username();
  std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // optional string password = 3;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  void set_password(const std::string& value);
  void set_password(std::string&& value);
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  std::string* mutable_password();
  std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional string domain = 4;
  bool has_domain() const;
  private:
  bool _internal_has_domain() const;
  public:
  void clear_domain();
  const std::string& domain() const;
  void set_domain(const std::string& value);
  void set_domain(std::string&& value);
  void set_domain(const char* value);
  void set_domain(const char* value, size_t size);
  std::string* mutable_domain();
  std::string* release_domain();
  void set_allocated_domain(std::string* domain);
  private:
  const std::string& _internal_domain() const;
  void _internal_set_domain(const std::string& value);
  std::string* _internal_mutable_domain();
  public:

  // optional string path = 6;
  bool has_path() const;
  private:
  bool _internal_has_path() const;
  public:
  void clear_path();
  const std::string& path() const;
  void set_path(const std::string& value);
  void set_path(std::string&& value);
  void set_path(const char* value);
  void set_path(const char* value, size_t size);
  std::string* mutable_path();
  std::string* release_path();
  void set_allocated_path(std::string* path);
  private:
  const std::string& _internal_path() const;
  void _internal_set_path(const std::string& value);
  std::string* _internal_mutable_path();
  public:

  // optional string query_string = 7;
  bool has_query_string() const;
  private:
  bool _internal_has_query_string() const;
  public:
  void clear_query_string();
  const std::string& query_string() const;
  void set_query_string(const std::string& value);
  void set_query_string(std::string&& value);
  void set_query_string(const char* value);
  void set_query_string(const char* value, size_t size);
  std::string* mutable_query_string();
  std::string* release_query_string();
  void set_allocated_query_string(std::string* query_string);
  private:
  const std::string& _internal_query_string() const;
  void _internal_set_query_string(const std::string& value);
  std::string* _internal_mutable_query_string();
  public:

  // optional string fragment_id = 8;
  bool has_fragment_id() const;
  private:
  bool _internal_has_fragment_id() const;
  public:
  void clear_fragment_id();
  const std::string& fragment_id() const;
  void set_fragment_id(const std::string& value);
  void set_fragment_id(std::string&& value);
  void set_fragment_id(const char* value);
  void set_fragment_id(const char* value, size_t size);
  std::string* mutable_fragment_id();
  std::string* release_fragment_id();
  void set_allocated_fragment_id(std::string* fragment_id);
  private:
  const std::string& _internal_fragment_id() const;
  void _internal_set_fragment_id(const std::string& value);
  std::string* _internal_mutable_fragment_id();
  public:

  // optional string morphosyntactic_features = 9;
  bool has_morphosyntactic_features() const;
  private:
  bool _internal_has_morphosyntactic_features() const;
  public:
  void clear_morphosyntactic_features();
  const std::string& morphosyntactic_features() const;
  void set_morphosyntactic_features(const std::string& value);
  void set_morphosyntactic_features(std::string&& value);
  void set_morphosyntactic_features(const char* value);
  void set_morphosyntactic_features(const char* value, size_t size);
  std::string* mutable_morphosyntactic_features();
  std::string* release_morphosyntactic_features();
  void set_allocated_morphosyntactic_features(std::string* morphosyntactic_features);
  private:
  const std::string& _internal_morphosyntactic_features() const;
  void _internal_set_morphosyntactic_features(const std::string& value);
  std::string* _internal_mutable_morphosyntactic_features();
  public:

  // optional string code_switch = 11;
  bool has_code_switch() const;
  private:
  bool _internal_has_code_switch() const;
  public:
  void clear_code_switch();
  const std::string& code_switch() const;
  void set_code_switch(const std::string& value);
  void set_code_switch(std::string&& value);
  void set_code_switch(const char* value);
  void set_code_switch(const char* value, size_t size);
  std::string* mutable_code_switch();
  std::string* release_code_switch();
  void set_allocated_code_switch(std::string* code_switch);
  private:
  const std::string& _internal_code_switch() const;
  void _internal_set_code_switch(const std::string& value);
  std::string* _internal_mutable_code_switch();
  public:

  // optional int32 port = 5;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  ::PROTOBUF_NAMESPACE_ID::int32 port() const;
  void set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_port() const;
  void _internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // optional bool preserve_order = 10;
  bool has_preserve_order() const;
  private:
  bool _internal_has_preserve_order() const;
  public:
  void clear_preserve_order();
  bool preserve_order() const;
  void set_preserve_order(bool value);
  private:
  bool _internal_preserve_order() const;
  void _internal_set_preserve_order(bool value);
  public:

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Electronic)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> field_order_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr protocol_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr domain_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr query_string_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fragment_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr morphosyntactic_features_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_switch_;
  ::PROTOBUF_NAMESPACE_ID::int32 port_;
  bool preserve_order_;
  friend struct ::TableStruct_semiotic_5fclasses_2eproto;
};
// -------------------------------------------------------------------

class Connector PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Connector) */ {
 public:
  inline Connector() : Connector(nullptr) {}
  virtual ~Connector();

  Connector(const Connector& from);
  Connector(Connector&& from) noexcept
    : Connector() {
    *this = ::std::move(from);
  }

  inline Connector& operator=(const Connector& from) {
    CopyFrom(from);
    return *this;
  }
  inline Connector& operator=(Connector&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Connector& default_instance();

  static inline const Connector* internal_default_instance() {
    return reinterpret_cast<const Connector*>(
               &_Connector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Connector& a, Connector& b) {
    a.Swap(&b);
  }
  inline void Swap(Connector* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Connector* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Connector* New() const final {
    return CreateMaybeMessage<Connector>(nullptr);
  }

  Connector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Connector>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Connector& from);
  void MergeFrom(const Connector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Connector* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.sparrowhawk.Connector";
  }
  protected:
  explicit Connector(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_semiotic_5fclasses_2eproto);
    return ::descriptor_table_semiotic_5fclasses_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kMorphosyntacticFeaturesFieldNumber = 2,
    kCodeSwitchFieldNumber = 3,
  };
  // optional string type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  void set_type(const std::string& value);
  void set_type(std::string&& value);
  void set_type(const char* value);
  void set_type(const char* value, size_t size);
  std::string* mutable_type();
  std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional string morphosyntactic_features = 2;
  bool has_morphosyntactic_features() const;
  private:
  bool _internal_has_morphosyntactic_features() const;
  public:
  void clear_morphosyntactic_features();
  const std::string& morphosyntactic_features() const;
  void set_morphosyntactic_features(const std::string& value);
  void set_morphosyntactic_features(std::string&& value);
  void set_morphosyntactic_features(const char* value);
  void set_morphosyntactic_features(const char* value, size_t size);
  std::string* mutable_morphosyntactic_features();
  std::string* release_morphosyntactic_features();
  void set_allocated_morphosyntactic_features(std::string* morphosyntactic_features);
  private:
  const std::string& _internal_morphosyntactic_features() const;
  void _internal_set_morphosyntactic_features(const std::string& value);
  std::string* _internal_mutable_morphosyntactic_features();
  public:

  // optional string code_switch = 3;
  bool has_code_switch() const;
  private:
  bool _internal_has_code_switch() const;
  public:
  void clear_code_switch();
  const std::string& code_switch() const;
  void set_code_switch(const std::string& value);
  void set_code_switch(std::string&& value);
  void set_code_switch(const char* value);
  void set_code_switch(const char* value, size_t size);
  std::string* mutable_code_switch();
  std::string* release_code_switch();
  void set_allocated_code_switch(std::string* code_switch);
  private:
  const std::string& _internal_code_switch() const;
  void _internal_set_code_switch(const std::string& value);
  std::string* _internal_mutable_code_switch();
  public:

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Connector)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr morphosyntactic_features_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_switch_;
  friend struct ::TableStruct_semiotic_5fclasses_2eproto;
};
// -------------------------------------------------------------------

class Abbreviation PROTOBUF_FINAL :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:speech.sparrowhawk.Abbreviation) */ {
 public:
  inline Abbreviation() : Abbreviation(nullptr) {}
  virtual ~Abbreviation();

  Abbreviation(const Abbreviation& from);
  Abbreviation(Abbreviation&& from) noexcept
    : Abbreviation() {
    *this = ::std::move(from);
  }

  inline Abbreviation& operator=(const Abbreviation& from) {
    CopyFrom(from);
    return *this;
  }
  inline Abbreviation& operator=(Abbreviation&& from) noexcept {
    if (GetArena() == from.GetArena()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const Abbreviation& default_instance();

  static inline const Abbreviation* internal_default_instance() {
    return reinterpret_cast<const Abbreviation*>(
               &_Abbreviation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(Abbreviation& a, Abbreviation& b) {
    a.Swap(&b);
  }
  inline void Swap(Abbreviation* other) {
    if (other == this) return;
    if (GetArena() == other->GetArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Abbreviation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Abbreviation* New() const final {
    return CreateMaybeMessage<Abbreviation>(nullptr);
  }

  Abbreviation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Abbreviation>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const Abbreviation& from);
  void MergeFrom(const Abbreviation& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Abbreviation* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "speech.sparrowhawk.Abbreviation";
  }
  protected:
  explicit Abbreviation(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_semiotic_5fclasses_2eproto);
    return ::descriptor_table_semiotic_5fclasses_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
    kMorphosyntacticFeaturesFieldNumber = 2,
    kCodeSwitchFieldNumber = 3,
  };
  // required string text = 1;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  void set_text(const std::string& value);
  void set_text(std::string&& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  std::string* mutable_text();
  std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // optional string morphosyntactic_features = 2;
  bool has_morphosyntactic_features() const;
  private:
  bool _internal_has_morphosyntactic_features() const;
  public:
  void clear_morphosyntactic_features();
  const std::string& morphosyntactic_features() const;
  void set_morphosyntactic_features(const std::string& value);
  void set_morphosyntactic_features(std::string&& value);
  void set_morphosyntactic_features(const char* value);
  void set_morphosyntactic_features(const char* value, size_t size);
  std::string* mutable_morphosyntactic_features();
  std::string* release_morphosyntactic_features();
  void set_allocated_morphosyntactic_features(std::string* morphosyntactic_features);
  private:
  const std::string& _internal_morphosyntactic_features() const;
  void _internal_set_morphosyntactic_features(const std::string& value);
  std::string* _internal_mutable_morphosyntactic_features();
  public:

  // optional string code_switch = 3;
  bool has_code_switch() const;
  private:
  bool _internal_has_code_switch() const;
  public:
  void clear_code_switch();
  const std::string& code_switch() const;
  void set_code_switch(const std::string& value);
  void set_code_switch(std::string&& value);
  void set_code_switch(const char* value);
  void set_code_switch(const char* value, size_t size);
  std::string* mutable_code_switch();
  std::string* release_code_switch();
  void set_allocated_code_switch(std::string* code_switch);
  private:
  const std::string& _internal_code_switch() const;
  void _internal_set_code_switch(const std::string& value);
  std::string* _internal_mutable_code_switch();
  public:

  // @@protoc_insertion_point(class_scope:speech.sparrowhawk.Abbreviation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr morphosyntactic_features_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_switch_;
  friend struct ::TableStruct_semiotic_5fclasses_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Cardinal

// required string integer = 1;
inline bool Cardinal::_internal_has_integer() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Cardinal::has_integer() const {
  return _internal_has_integer();
}
inline void Cardinal::clear_integer() {
  integer_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Cardinal::integer() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Cardinal.integer)
  return _internal_integer();
}
inline void Cardinal::set_integer(const std::string& value) {
  _internal_set_integer(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Cardinal.integer)
}
inline std::string* Cardinal::mutable_integer() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Cardinal.integer)
  return _internal_mutable_integer();
}
inline const std::string& Cardinal::_internal_integer() const {
  return integer_.Get();
}
inline void Cardinal::_internal_set_integer(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  integer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Cardinal::set_integer(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  integer_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Cardinal.integer)
}
inline void Cardinal::set_integer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  integer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Cardinal.integer)
}
inline void Cardinal::set_integer(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  integer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Cardinal.integer)
}
inline std::string* Cardinal::_internal_mutable_integer() {
  _has_bits_[0] |= 0x00000001u;
  return integer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Cardinal::release_integer() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Cardinal.integer)
  if (!_internal_has_integer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return integer_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Cardinal::set_allocated_integer(std::string* integer) {
  if (integer != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  integer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), integer,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Cardinal.integer)
}

// optional string morphosyntactic_features = 2;
inline bool Cardinal::_internal_has_morphosyntactic_features() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Cardinal::has_morphosyntactic_features() const {
  return _internal_has_morphosyntactic_features();
}
inline void Cardinal::clear_morphosyntactic_features() {
  morphosyntactic_features_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Cardinal::morphosyntactic_features() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Cardinal.morphosyntactic_features)
  return _internal_morphosyntactic_features();
}
inline void Cardinal::set_morphosyntactic_features(const std::string& value) {
  _internal_set_morphosyntactic_features(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Cardinal.morphosyntactic_features)
}
inline std::string* Cardinal::mutable_morphosyntactic_features() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Cardinal.morphosyntactic_features)
  return _internal_mutable_morphosyntactic_features();
}
inline const std::string& Cardinal::_internal_morphosyntactic_features() const {
  return morphosyntactic_features_.Get();
}
inline void Cardinal::_internal_set_morphosyntactic_features(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Cardinal::set_morphosyntactic_features(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  morphosyntactic_features_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Cardinal.morphosyntactic_features)
}
inline void Cardinal::set_morphosyntactic_features(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Cardinal.morphosyntactic_features)
}
inline void Cardinal::set_morphosyntactic_features(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Cardinal.morphosyntactic_features)
}
inline std::string* Cardinal::_internal_mutable_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000002u;
  return morphosyntactic_features_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Cardinal::release_morphosyntactic_features() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Cardinal.morphosyntactic_features)
  if (!_internal_has_morphosyntactic_features()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return morphosyntactic_features_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Cardinal::set_allocated_morphosyntactic_features(std::string* morphosyntactic_features) {
  if (morphosyntactic_features != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  morphosyntactic_features_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), morphosyntactic_features,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Cardinal.morphosyntactic_features)
}

// optional bool preserve_order = 3;
inline bool Cardinal::_internal_has_preserve_order() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Cardinal::has_preserve_order() const {
  return _internal_has_preserve_order();
}
inline void Cardinal::clear_preserve_order() {
  preserve_order_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool Cardinal::_internal_preserve_order() const {
  return preserve_order_;
}
inline bool Cardinal::preserve_order() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Cardinal.preserve_order)
  return _internal_preserve_order();
}
inline void Cardinal::_internal_set_preserve_order(bool value) {
  _has_bits_[0] |= 0x00000008u;
  preserve_order_ = value;
}
inline void Cardinal::set_preserve_order(bool value) {
  _internal_set_preserve_order(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Cardinal.preserve_order)
}

// optional string code_switch = 4;
inline bool Cardinal::_internal_has_code_switch() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Cardinal::has_code_switch() const {
  return _internal_has_code_switch();
}
inline void Cardinal::clear_code_switch() {
  code_switch_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Cardinal::code_switch() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Cardinal.code_switch)
  return _internal_code_switch();
}
inline void Cardinal::set_code_switch(const std::string& value) {
  _internal_set_code_switch(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Cardinal.code_switch)
}
inline std::string* Cardinal::mutable_code_switch() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Cardinal.code_switch)
  return _internal_mutable_code_switch();
}
inline const std::string& Cardinal::_internal_code_switch() const {
  return code_switch_.Get();
}
inline void Cardinal::_internal_set_code_switch(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Cardinal::set_code_switch(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  code_switch_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Cardinal.code_switch)
}
inline void Cardinal::set_code_switch(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Cardinal.code_switch)
}
inline void Cardinal::set_code_switch(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Cardinal.code_switch)
}
inline std::string* Cardinal::_internal_mutable_code_switch() {
  _has_bits_[0] |= 0x00000004u;
  return code_switch_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Cardinal::release_code_switch() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Cardinal.code_switch)
  if (!_internal_has_code_switch()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return code_switch_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Cardinal::set_allocated_code_switch(std::string* code_switch) {
  if (code_switch != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  code_switch_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code_switch,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Cardinal.code_switch)
}

// repeated string field_order = 5;
inline int Cardinal::_internal_field_order_size() const {
  return field_order_.size();
}
inline int Cardinal::field_order_size() const {
  return _internal_field_order_size();
}
inline void Cardinal::clear_field_order() {
  field_order_.Clear();
}
inline std::string* Cardinal::add_field_order() {
  // @@protoc_insertion_point(field_add_mutable:speech.sparrowhawk.Cardinal.field_order)
  return _internal_add_field_order();
}
inline const std::string& Cardinal::_internal_field_order(int index) const {
  return field_order_.Get(index);
}
inline const std::string& Cardinal::field_order(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Cardinal.field_order)
  return _internal_field_order(index);
}
inline std::string* Cardinal::mutable_field_order(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Cardinal.field_order)
  return field_order_.Mutable(index);
}
inline void Cardinal::set_field_order(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Cardinal.field_order)
  field_order_.Mutable(index)->assign(value);
}
inline void Cardinal::set_field_order(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Cardinal.field_order)
  field_order_.Mutable(index)->assign(std::move(value));
}
inline void Cardinal::set_field_order(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  field_order_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Cardinal.field_order)
}
inline void Cardinal::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Cardinal.field_order)
}
inline std::string* Cardinal::_internal_add_field_order() {
  return field_order_.Add();
}
inline void Cardinal::add_field_order(const std::string& value) {
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Cardinal.field_order)
}
inline void Cardinal::add_field_order(std::string&& value) {
  field_order_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Cardinal.field_order)
}
inline void Cardinal::add_field_order(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.sparrowhawk.Cardinal.field_order)
}
inline void Cardinal::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.sparrowhawk.Cardinal.field_order)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Cardinal::field_order() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.Cardinal.field_order)
  return field_order_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Cardinal::mutable_field_order() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.Cardinal.field_order)
  return &field_order_;
}

// -------------------------------------------------------------------

// Ordinal

// required string integer = 1;
inline bool Ordinal::_internal_has_integer() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Ordinal::has_integer() const {
  return _internal_has_integer();
}
inline void Ordinal::clear_integer() {
  integer_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Ordinal::integer() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Ordinal.integer)
  return _internal_integer();
}
inline void Ordinal::set_integer(const std::string& value) {
  _internal_set_integer(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Ordinal.integer)
}
inline std::string* Ordinal::mutable_integer() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Ordinal.integer)
  return _internal_mutable_integer();
}
inline const std::string& Ordinal::_internal_integer() const {
  return integer_.Get();
}
inline void Ordinal::_internal_set_integer(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  integer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Ordinal::set_integer(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  integer_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Ordinal.integer)
}
inline void Ordinal::set_integer(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  integer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Ordinal.integer)
}
inline void Ordinal::set_integer(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  integer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Ordinal.integer)
}
inline std::string* Ordinal::_internal_mutable_integer() {
  _has_bits_[0] |= 0x00000001u;
  return integer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Ordinal::release_integer() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Ordinal.integer)
  if (!_internal_has_integer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return integer_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Ordinal::set_allocated_integer(std::string* integer) {
  if (integer != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  integer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), integer,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Ordinal.integer)
}

// optional string morphosyntactic_features = 2;
inline bool Ordinal::_internal_has_morphosyntactic_features() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Ordinal::has_morphosyntactic_features() const {
  return _internal_has_morphosyntactic_features();
}
inline void Ordinal::clear_morphosyntactic_features() {
  morphosyntactic_features_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Ordinal::morphosyntactic_features() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Ordinal.morphosyntactic_features)
  return _internal_morphosyntactic_features();
}
inline void Ordinal::set_morphosyntactic_features(const std::string& value) {
  _internal_set_morphosyntactic_features(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Ordinal.morphosyntactic_features)
}
inline std::string* Ordinal::mutable_morphosyntactic_features() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Ordinal.morphosyntactic_features)
  return _internal_mutable_morphosyntactic_features();
}
inline const std::string& Ordinal::_internal_morphosyntactic_features() const {
  return morphosyntactic_features_.Get();
}
inline void Ordinal::_internal_set_morphosyntactic_features(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Ordinal::set_morphosyntactic_features(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  morphosyntactic_features_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Ordinal.morphosyntactic_features)
}
inline void Ordinal::set_morphosyntactic_features(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Ordinal.morphosyntactic_features)
}
inline void Ordinal::set_morphosyntactic_features(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Ordinal.morphosyntactic_features)
}
inline std::string* Ordinal::_internal_mutable_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000002u;
  return morphosyntactic_features_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Ordinal::release_morphosyntactic_features() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Ordinal.morphosyntactic_features)
  if (!_internal_has_morphosyntactic_features()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return morphosyntactic_features_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Ordinal::set_allocated_morphosyntactic_features(std::string* morphosyntactic_features) {
  if (morphosyntactic_features != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  morphosyntactic_features_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), morphosyntactic_features,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Ordinal.morphosyntactic_features)
}

// optional bool preserve_order = 3;
inline bool Ordinal::_internal_has_preserve_order() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Ordinal::has_preserve_order() const {
  return _internal_has_preserve_order();
}
inline void Ordinal::clear_preserve_order() {
  preserve_order_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool Ordinal::_internal_preserve_order() const {
  return preserve_order_;
}
inline bool Ordinal::preserve_order() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Ordinal.preserve_order)
  return _internal_preserve_order();
}
inline void Ordinal::_internal_set_preserve_order(bool value) {
  _has_bits_[0] |= 0x00000008u;
  preserve_order_ = value;
}
inline void Ordinal::set_preserve_order(bool value) {
  _internal_set_preserve_order(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Ordinal.preserve_order)
}

// optional string code_switch = 4;
inline bool Ordinal::_internal_has_code_switch() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Ordinal::has_code_switch() const {
  return _internal_has_code_switch();
}
inline void Ordinal::clear_code_switch() {
  code_switch_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Ordinal::code_switch() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Ordinal.code_switch)
  return _internal_code_switch();
}
inline void Ordinal::set_code_switch(const std::string& value) {
  _internal_set_code_switch(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Ordinal.code_switch)
}
inline std::string* Ordinal::mutable_code_switch() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Ordinal.code_switch)
  return _internal_mutable_code_switch();
}
inline const std::string& Ordinal::_internal_code_switch() const {
  return code_switch_.Get();
}
inline void Ordinal::_internal_set_code_switch(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Ordinal::set_code_switch(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  code_switch_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Ordinal.code_switch)
}
inline void Ordinal::set_code_switch(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Ordinal.code_switch)
}
inline void Ordinal::set_code_switch(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Ordinal.code_switch)
}
inline std::string* Ordinal::_internal_mutable_code_switch() {
  _has_bits_[0] |= 0x00000004u;
  return code_switch_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Ordinal::release_code_switch() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Ordinal.code_switch)
  if (!_internal_has_code_switch()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return code_switch_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Ordinal::set_allocated_code_switch(std::string* code_switch) {
  if (code_switch != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  code_switch_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code_switch,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Ordinal.code_switch)
}

// repeated string field_order = 5;
inline int Ordinal::_internal_field_order_size() const {
  return field_order_.size();
}
inline int Ordinal::field_order_size() const {
  return _internal_field_order_size();
}
inline void Ordinal::clear_field_order() {
  field_order_.Clear();
}
inline std::string* Ordinal::add_field_order() {
  // @@protoc_insertion_point(field_add_mutable:speech.sparrowhawk.Ordinal.field_order)
  return _internal_add_field_order();
}
inline const std::string& Ordinal::_internal_field_order(int index) const {
  return field_order_.Get(index);
}
inline const std::string& Ordinal::field_order(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Ordinal.field_order)
  return _internal_field_order(index);
}
inline std::string* Ordinal::mutable_field_order(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Ordinal.field_order)
  return field_order_.Mutable(index);
}
inline void Ordinal::set_field_order(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Ordinal.field_order)
  field_order_.Mutable(index)->assign(value);
}
inline void Ordinal::set_field_order(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Ordinal.field_order)
  field_order_.Mutable(index)->assign(std::move(value));
}
inline void Ordinal::set_field_order(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  field_order_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Ordinal.field_order)
}
inline void Ordinal::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Ordinal.field_order)
}
inline std::string* Ordinal::_internal_add_field_order() {
  return field_order_.Add();
}
inline void Ordinal::add_field_order(const std::string& value) {
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Ordinal.field_order)
}
inline void Ordinal::add_field_order(std::string&& value) {
  field_order_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Ordinal.field_order)
}
inline void Ordinal::add_field_order(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.sparrowhawk.Ordinal.field_order)
}
inline void Ordinal::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.sparrowhawk.Ordinal.field_order)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Ordinal::field_order() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.Ordinal.field_order)
  return field_order_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Ordinal::mutable_field_order() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.Ordinal.field_order)
  return &field_order_;
}

// -------------------------------------------------------------------

// Fraction

// optional string integer_part = 1;
inline bool Fraction::_internal_has_integer_part() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Fraction::has_integer_part() const {
  return _internal_has_integer_part();
}
inline void Fraction::clear_integer_part() {
  integer_part_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Fraction::integer_part() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Fraction.integer_part)
  return _internal_integer_part();
}
inline void Fraction::set_integer_part(const std::string& value) {
  _internal_set_integer_part(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Fraction.integer_part)
}
inline std::string* Fraction::mutable_integer_part() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Fraction.integer_part)
  return _internal_mutable_integer_part();
}
inline const std::string& Fraction::_internal_integer_part() const {
  return integer_part_.Get();
}
inline void Fraction::_internal_set_integer_part(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  integer_part_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Fraction::set_integer_part(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  integer_part_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Fraction.integer_part)
}
inline void Fraction::set_integer_part(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  integer_part_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Fraction.integer_part)
}
inline void Fraction::set_integer_part(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  integer_part_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Fraction.integer_part)
}
inline std::string* Fraction::_internal_mutable_integer_part() {
  _has_bits_[0] |= 0x00000001u;
  return integer_part_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Fraction::release_integer_part() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Fraction.integer_part)
  if (!_internal_has_integer_part()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return integer_part_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Fraction::set_allocated_integer_part(std::string* integer_part) {
  if (integer_part != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  integer_part_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), integer_part,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Fraction.integer_part)
}

// required string numerator = 2;
inline bool Fraction::_internal_has_numerator() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Fraction::has_numerator() const {
  return _internal_has_numerator();
}
inline void Fraction::clear_numerator() {
  numerator_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Fraction::numerator() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Fraction.numerator)
  return _internal_numerator();
}
inline void Fraction::set_numerator(const std::string& value) {
  _internal_set_numerator(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Fraction.numerator)
}
inline std::string* Fraction::mutable_numerator() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Fraction.numerator)
  return _internal_mutable_numerator();
}
inline const std::string& Fraction::_internal_numerator() const {
  return numerator_.Get();
}
inline void Fraction::_internal_set_numerator(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  numerator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Fraction::set_numerator(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  numerator_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Fraction.numerator)
}
inline void Fraction::set_numerator(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  numerator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Fraction.numerator)
}
inline void Fraction::set_numerator(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  numerator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Fraction.numerator)
}
inline std::string* Fraction::_internal_mutable_numerator() {
  _has_bits_[0] |= 0x00000002u;
  return numerator_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Fraction::release_numerator() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Fraction.numerator)
  if (!_internal_has_numerator()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return numerator_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Fraction::set_allocated_numerator(std::string* numerator) {
  if (numerator != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  numerator_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), numerator,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Fraction.numerator)
}

// required string denominator = 3;
inline bool Fraction::_internal_has_denominator() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Fraction::has_denominator() const {
  return _internal_has_denominator();
}
inline void Fraction::clear_denominator() {
  denominator_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Fraction::denominator() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Fraction.denominator)
  return _internal_denominator();
}
inline void Fraction::set_denominator(const std::string& value) {
  _internal_set_denominator(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Fraction.denominator)
}
inline std::string* Fraction::mutable_denominator() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Fraction.denominator)
  return _internal_mutable_denominator();
}
inline const std::string& Fraction::_internal_denominator() const {
  return denominator_.Get();
}
inline void Fraction::_internal_set_denominator(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  denominator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Fraction::set_denominator(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  denominator_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Fraction.denominator)
}
inline void Fraction::set_denominator(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  denominator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Fraction.denominator)
}
inline void Fraction::set_denominator(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  denominator_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Fraction.denominator)
}
inline std::string* Fraction::_internal_mutable_denominator() {
  _has_bits_[0] |= 0x00000004u;
  return denominator_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Fraction::release_denominator() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Fraction.denominator)
  if (!_internal_has_denominator()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return denominator_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Fraction::set_allocated_denominator(std::string* denominator) {
  if (denominator != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  denominator_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), denominator,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Fraction.denominator)
}

// optional int32 style = 4 [deprecated = true];
inline bool Fraction::_internal_has_style() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Fraction::has_style() const {
  return _internal_has_style();
}
inline void Fraction::clear_style() {
  style_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Fraction::_internal_style() const {
  return style_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Fraction::style() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Fraction.style)
  return _internal_style();
}
inline void Fraction::_internal_set_style(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  style_ = value;
}
inline void Fraction::set_style(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_style(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Fraction.style)
}

// optional string morphosyntactic_features = 5;
inline bool Fraction::_internal_has_morphosyntactic_features() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Fraction::has_morphosyntactic_features() const {
  return _internal_has_morphosyntactic_features();
}
inline void Fraction::clear_morphosyntactic_features() {
  morphosyntactic_features_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Fraction::morphosyntactic_features() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Fraction.morphosyntactic_features)
  return _internal_morphosyntactic_features();
}
inline void Fraction::set_morphosyntactic_features(const std::string& value) {
  _internal_set_morphosyntactic_features(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Fraction.morphosyntactic_features)
}
inline std::string* Fraction::mutable_morphosyntactic_features() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Fraction.morphosyntactic_features)
  return _internal_mutable_morphosyntactic_features();
}
inline const std::string& Fraction::_internal_morphosyntactic_features() const {
  return morphosyntactic_features_.Get();
}
inline void Fraction::_internal_set_morphosyntactic_features(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Fraction::set_morphosyntactic_features(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  morphosyntactic_features_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Fraction.morphosyntactic_features)
}
inline void Fraction::set_morphosyntactic_features(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Fraction.morphosyntactic_features)
}
inline void Fraction::set_morphosyntactic_features(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Fraction.morphosyntactic_features)
}
inline std::string* Fraction::_internal_mutable_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000008u;
  return morphosyntactic_features_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Fraction::release_morphosyntactic_features() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Fraction.morphosyntactic_features)
  if (!_internal_has_morphosyntactic_features()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return morphosyntactic_features_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Fraction::set_allocated_morphosyntactic_features(std::string* morphosyntactic_features) {
  if (morphosyntactic_features != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  morphosyntactic_features_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), morphosyntactic_features,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Fraction.morphosyntactic_features)
}

// optional bool preserve_order = 6;
inline bool Fraction::_internal_has_preserve_order() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Fraction::has_preserve_order() const {
  return _internal_has_preserve_order();
}
inline void Fraction::clear_preserve_order() {
  preserve_order_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool Fraction::_internal_preserve_order() const {
  return preserve_order_;
}
inline bool Fraction::preserve_order() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Fraction.preserve_order)
  return _internal_preserve_order();
}
inline void Fraction::_internal_set_preserve_order(bool value) {
  _has_bits_[0] |= 0x00000040u;
  preserve_order_ = value;
}
inline void Fraction::set_preserve_order(bool value) {
  _internal_set_preserve_order(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Fraction.preserve_order)
}

// optional string code_switch = 7;
inline bool Fraction::_internal_has_code_switch() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Fraction::has_code_switch() const {
  return _internal_has_code_switch();
}
inline void Fraction::clear_code_switch() {
  code_switch_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Fraction::code_switch() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Fraction.code_switch)
  return _internal_code_switch();
}
inline void Fraction::set_code_switch(const std::string& value) {
  _internal_set_code_switch(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Fraction.code_switch)
}
inline std::string* Fraction::mutable_code_switch() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Fraction.code_switch)
  return _internal_mutable_code_switch();
}
inline const std::string& Fraction::_internal_code_switch() const {
  return code_switch_.Get();
}
inline void Fraction::_internal_set_code_switch(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Fraction::set_code_switch(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  code_switch_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Fraction.code_switch)
}
inline void Fraction::set_code_switch(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Fraction.code_switch)
}
inline void Fraction::set_code_switch(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000010u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Fraction.code_switch)
}
inline std::string* Fraction::_internal_mutable_code_switch() {
  _has_bits_[0] |= 0x00000010u;
  return code_switch_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Fraction::release_code_switch() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Fraction.code_switch)
  if (!_internal_has_code_switch()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return code_switch_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Fraction::set_allocated_code_switch(std::string* code_switch) {
  if (code_switch != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  code_switch_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code_switch,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Fraction.code_switch)
}

// optional bool negative = 8;
inline bool Fraction::_internal_has_negative() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Fraction::has_negative() const {
  return _internal_has_negative();
}
inline void Fraction::clear_negative() {
  negative_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool Fraction::_internal_negative() const {
  return negative_;
}
inline bool Fraction::negative() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Fraction.negative)
  return _internal_negative();
}
inline void Fraction::_internal_set_negative(bool value) {
  _has_bits_[0] |= 0x00000080u;
  negative_ = value;
}
inline void Fraction::set_negative(bool value) {
  _internal_set_negative(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Fraction.negative)
}

// repeated string field_order = 9;
inline int Fraction::_internal_field_order_size() const {
  return field_order_.size();
}
inline int Fraction::field_order_size() const {
  return _internal_field_order_size();
}
inline void Fraction::clear_field_order() {
  field_order_.Clear();
}
inline std::string* Fraction::add_field_order() {
  // @@protoc_insertion_point(field_add_mutable:speech.sparrowhawk.Fraction.field_order)
  return _internal_add_field_order();
}
inline const std::string& Fraction::_internal_field_order(int index) const {
  return field_order_.Get(index);
}
inline const std::string& Fraction::field_order(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Fraction.field_order)
  return _internal_field_order(index);
}
inline std::string* Fraction::mutable_field_order(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Fraction.field_order)
  return field_order_.Mutable(index);
}
inline void Fraction::set_field_order(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Fraction.field_order)
  field_order_.Mutable(index)->assign(value);
}
inline void Fraction::set_field_order(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Fraction.field_order)
  field_order_.Mutable(index)->assign(std::move(value));
}
inline void Fraction::set_field_order(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  field_order_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Fraction.field_order)
}
inline void Fraction::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Fraction.field_order)
}
inline std::string* Fraction::_internal_add_field_order() {
  return field_order_.Add();
}
inline void Fraction::add_field_order(const std::string& value) {
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Fraction.field_order)
}
inline void Fraction::add_field_order(std::string&& value) {
  field_order_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Fraction.field_order)
}
inline void Fraction::add_field_order(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.sparrowhawk.Fraction.field_order)
}
inline void Fraction::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.sparrowhawk.Fraction.field_order)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Fraction::field_order() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.Fraction.field_order)
  return field_order_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Fraction::mutable_field_order() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.Fraction.field_order)
  return &field_order_;
}

// -------------------------------------------------------------------

// Time

// optional int32 hours = 1;
inline bool Time::_internal_has_hours() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Time::has_hours() const {
  return _internal_has_hours();
}
inline void Time::clear_hours() {
  hours_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Time::_internal_hours() const {
  return hours_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Time::hours() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Time.hours)
  return _internal_hours();
}
inline void Time::_internal_set_hours(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  hours_ = value;
}
inline void Time::set_hours(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_hours(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Time.hours)
}

// optional int32 minutes = 2;
inline bool Time::_internal_has_minutes() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Time::has_minutes() const {
  return _internal_has_minutes();
}
inline void Time::clear_minutes() {
  minutes_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Time::_internal_minutes() const {
  return minutes_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Time::minutes() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Time.minutes)
  return _internal_minutes();
}
inline void Time::_internal_set_minutes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  minutes_ = value;
}
inline void Time::set_minutes(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_minutes(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Time.minutes)
}

// optional int32 seconds = 3 [deprecated = true];
inline bool Time::_internal_has_seconds() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Time::has_seconds() const {
  return _internal_has_seconds();
}
inline void Time::clear_seconds() {
  seconds_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Time::_internal_seconds() const {
  return seconds_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Time::seconds() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Time.seconds)
  return _internal_seconds();
}
inline void Time::_internal_set_seconds(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  seconds_ = value;
}
inline void Time::set_seconds(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Time.seconds)
}

// optional bool speak_period = 4;
inline bool Time::_internal_has_speak_period() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Time::has_speak_period() const {
  return _internal_has_speak_period();
}
inline void Time::clear_speak_period() {
  speak_period_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool Time::_internal_speak_period() const {
  return speak_period_;
}
inline bool Time::speak_period() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Time.speak_period)
  return _internal_speak_period();
}
inline void Time::_internal_set_speak_period(bool value) {
  _has_bits_[0] |= 0x00000100u;
  speak_period_ = value;
}
inline void Time::set_speak_period(bool value) {
  _internal_set_speak_period(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Time.speak_period)
}

// optional string suffix = 5 [deprecated = true];
inline bool Time::_internal_has_suffix() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Time::has_suffix() const {
  return _internal_has_suffix();
}
inline void Time::clear_suffix() {
  suffix_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Time::suffix() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Time.suffix)
  return _internal_suffix();
}
inline void Time::set_suffix(const std::string& value) {
  _internal_set_suffix(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Time.suffix)
}
inline std::string* Time::mutable_suffix() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Time.suffix)
  return _internal_mutable_suffix();
}
inline const std::string& Time::_internal_suffix() const {
  return suffix_.Get();
}
inline void Time::_internal_set_suffix(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  suffix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Time::set_suffix(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  suffix_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Time.suffix)
}
inline void Time::set_suffix(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  suffix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Time.suffix)
}
inline void Time::set_suffix(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  suffix_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Time.suffix)
}
inline std::string* Time::_internal_mutable_suffix() {
  _has_bits_[0] |= 0x00000001u;
  return suffix_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Time::release_suffix() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Time.suffix)
  if (!_internal_has_suffix()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return suffix_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Time::set_allocated_suffix(std::string* suffix) {
  if (suffix != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  suffix_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), suffix,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Time.suffix)
}

// optional int32 style = 6 [deprecated = true];
inline bool Time::_internal_has_style() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Time::has_style() const {
  return _internal_has_style();
}
inline void Time::clear_style() {
  style_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Time::_internal_style() const {
  return style_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Time::style() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Time.style)
  return _internal_style();
}
inline void Time::_internal_set_style(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000080u;
  style_ = value;
}
inline void Time::set_style(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_style(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Time.style)
}

// optional string zone = 7;
inline bool Time::_internal_has_zone() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Time::has_zone() const {
  return _internal_has_zone();
}
inline void Time::clear_zone() {
  zone_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Time::zone() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Time.zone)
  return _internal_zone();
}
inline void Time::set_zone(const std::string& value) {
  _internal_set_zone(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Time.zone)
}
inline std::string* Time::mutable_zone() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Time.zone)
  return _internal_mutable_zone();
}
inline const std::string& Time::_internal_zone() const {
  return zone_.Get();
}
inline void Time::_internal_set_zone(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  zone_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Time::set_zone(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  zone_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Time.zone)
}
inline void Time::set_zone(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  zone_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Time.zone)
}
inline void Time::set_zone(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  zone_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Time.zone)
}
inline std::string* Time::_internal_mutable_zone() {
  _has_bits_[0] |= 0x00000002u;
  return zone_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Time::release_zone() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Time.zone)
  if (!_internal_has_zone()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return zone_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Time::set_allocated_zone(std::string* zone) {
  if (zone != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  zone_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), zone,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Time.zone)
}

// optional string morphosyntactic_features = 9;
inline bool Time::_internal_has_morphosyntactic_features() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Time::has_morphosyntactic_features() const {
  return _internal_has_morphosyntactic_features();
}
inline void Time::clear_morphosyntactic_features() {
  morphosyntactic_features_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Time::morphosyntactic_features() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Time.morphosyntactic_features)
  return _internal_morphosyntactic_features();
}
inline void Time::set_morphosyntactic_features(const std::string& value) {
  _internal_set_morphosyntactic_features(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Time.morphosyntactic_features)
}
inline std::string* Time::mutable_morphosyntactic_features() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Time.morphosyntactic_features)
  return _internal_mutable_morphosyntactic_features();
}
inline const std::string& Time::_internal_morphosyntactic_features() const {
  return morphosyntactic_features_.Get();
}
inline void Time::_internal_set_morphosyntactic_features(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Time::set_morphosyntactic_features(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  morphosyntactic_features_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Time.morphosyntactic_features)
}
inline void Time::set_morphosyntactic_features(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Time.morphosyntactic_features)
}
inline void Time::set_morphosyntactic_features(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Time.morphosyntactic_features)
}
inline std::string* Time::_internal_mutable_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000004u;
  return morphosyntactic_features_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Time::release_morphosyntactic_features() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Time.morphosyntactic_features)
  if (!_internal_has_morphosyntactic_features()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return morphosyntactic_features_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Time::set_allocated_morphosyntactic_features(std::string* morphosyntactic_features) {
  if (morphosyntactic_features != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  morphosyntactic_features_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), morphosyntactic_features,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Time.morphosyntactic_features)
}

// optional bool preserve_order = 10;
inline bool Time::_internal_has_preserve_order() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Time::has_preserve_order() const {
  return _internal_has_preserve_order();
}
inline void Time::clear_preserve_order() {
  preserve_order_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool Time::_internal_preserve_order() const {
  return preserve_order_;
}
inline bool Time::preserve_order() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Time.preserve_order)
  return _internal_preserve_order();
}
inline void Time::_internal_set_preserve_order(bool value) {
  _has_bits_[0] |= 0x00000200u;
  preserve_order_ = value;
}
inline void Time::set_preserve_order(bool value) {
  _internal_set_preserve_order(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Time.preserve_order)
}

// optional string code_switch = 11;
inline bool Time::_internal_has_code_switch() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Time::has_code_switch() const {
  return _internal_has_code_switch();
}
inline void Time::clear_code_switch() {
  code_switch_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Time::code_switch() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Time.code_switch)
  return _internal_code_switch();
}
inline void Time::set_code_switch(const std::string& value) {
  _internal_set_code_switch(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Time.code_switch)
}
inline std::string* Time::mutable_code_switch() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Time.code_switch)
  return _internal_mutable_code_switch();
}
inline const std::string& Time::_internal_code_switch() const {
  return code_switch_.Get();
}
inline void Time::_internal_set_code_switch(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Time::set_code_switch(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  code_switch_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Time.code_switch)
}
inline void Time::set_code_switch(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Time.code_switch)
}
inline void Time::set_code_switch(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Time.code_switch)
}
inline std::string* Time::_internal_mutable_code_switch() {
  _has_bits_[0] |= 0x00000008u;
  return code_switch_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Time::release_code_switch() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Time.code_switch)
  if (!_internal_has_code_switch()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return code_switch_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Time::set_allocated_code_switch(std::string* code_switch) {
  if (code_switch != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  code_switch_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code_switch,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Time.code_switch)
}

// repeated string field_order = 12;
inline int Time::_internal_field_order_size() const {
  return field_order_.size();
}
inline int Time::field_order_size() const {
  return _internal_field_order_size();
}
inline void Time::clear_field_order() {
  field_order_.Clear();
}
inline std::string* Time::add_field_order() {
  // @@protoc_insertion_point(field_add_mutable:speech.sparrowhawk.Time.field_order)
  return _internal_add_field_order();
}
inline const std::string& Time::_internal_field_order(int index) const {
  return field_order_.Get(index);
}
inline const std::string& Time::field_order(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Time.field_order)
  return _internal_field_order(index);
}
inline std::string* Time::mutable_field_order(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Time.field_order)
  return field_order_.Mutable(index);
}
inline void Time::set_field_order(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Time.field_order)
  field_order_.Mutable(index)->assign(value);
}
inline void Time::set_field_order(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Time.field_order)
  field_order_.Mutable(index)->assign(std::move(value));
}
inline void Time::set_field_order(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  field_order_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Time.field_order)
}
inline void Time::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Time.field_order)
}
inline std::string* Time::_internal_add_field_order() {
  return field_order_.Add();
}
inline void Time::add_field_order(const std::string& value) {
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Time.field_order)
}
inline void Time::add_field_order(std::string&& value) {
  field_order_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Time.field_order)
}
inline void Time::add_field_order(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.sparrowhawk.Time.field_order)
}
inline void Time::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.sparrowhawk.Time.field_order)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Time::field_order() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.Time.field_order)
  return field_order_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Time::mutable_field_order() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.Time.field_order)
  return &field_order_;
}

// -------------------------------------------------------------------

// Decimal

// optional bool negative = 1;
inline bool Decimal::_internal_has_negative() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Decimal::has_negative() const {
  return _internal_has_negative();
}
inline void Decimal::clear_negative() {
  negative_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool Decimal::_internal_negative() const {
  return negative_;
}
inline bool Decimal::negative() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Decimal.negative)
  return _internal_negative();
}
inline void Decimal::_internal_set_negative(bool value) {
  _has_bits_[0] |= 0x00000040u;
  negative_ = value;
}
inline void Decimal::set_negative(bool value) {
  _internal_set_negative(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Decimal.negative)
}

// optional string integer_part = 2;
inline bool Decimal::_internal_has_integer_part() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Decimal::has_integer_part() const {
  return _internal_has_integer_part();
}
inline void Decimal::clear_integer_part() {
  integer_part_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Decimal::integer_part() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Decimal.integer_part)
  return _internal_integer_part();
}
inline void Decimal::set_integer_part(const std::string& value) {
  _internal_set_integer_part(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Decimal.integer_part)
}
inline std::string* Decimal::mutable_integer_part() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Decimal.integer_part)
  return _internal_mutable_integer_part();
}
inline const std::string& Decimal::_internal_integer_part() const {
  return integer_part_.Get();
}
inline void Decimal::_internal_set_integer_part(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  integer_part_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Decimal::set_integer_part(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  integer_part_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Decimal.integer_part)
}
inline void Decimal::set_integer_part(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  integer_part_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Decimal.integer_part)
}
inline void Decimal::set_integer_part(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  integer_part_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Decimal.integer_part)
}
inline std::string* Decimal::_internal_mutable_integer_part() {
  _has_bits_[0] |= 0x00000001u;
  return integer_part_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Decimal::release_integer_part() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Decimal.integer_part)
  if (!_internal_has_integer_part()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return integer_part_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Decimal::set_allocated_integer_part(std::string* integer_part) {
  if (integer_part != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  integer_part_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), integer_part,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Decimal.integer_part)
}

// optional string fractional_part = 3;
inline bool Decimal::_internal_has_fractional_part() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Decimal::has_fractional_part() const {
  return _internal_has_fractional_part();
}
inline void Decimal::clear_fractional_part() {
  fractional_part_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Decimal::fractional_part() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Decimal.fractional_part)
  return _internal_fractional_part();
}
inline void Decimal::set_fractional_part(const std::string& value) {
  _internal_set_fractional_part(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Decimal.fractional_part)
}
inline std::string* Decimal::mutable_fractional_part() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Decimal.fractional_part)
  return _internal_mutable_fractional_part();
}
inline const std::string& Decimal::_internal_fractional_part() const {
  return fractional_part_.Get();
}
inline void Decimal::_internal_set_fractional_part(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  fractional_part_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Decimal::set_fractional_part(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  fractional_part_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Decimal.fractional_part)
}
inline void Decimal::set_fractional_part(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  fractional_part_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Decimal.fractional_part)
}
inline void Decimal::set_fractional_part(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  fractional_part_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Decimal.fractional_part)
}
inline std::string* Decimal::_internal_mutable_fractional_part() {
  _has_bits_[0] |= 0x00000002u;
  return fractional_part_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Decimal::release_fractional_part() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Decimal.fractional_part)
  if (!_internal_has_fractional_part()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return fractional_part_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Decimal::set_allocated_fractional_part(std::string* fractional_part) {
  if (fractional_part != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  fractional_part_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fractional_part,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Decimal.fractional_part)
}

// optional string quantity = 4;
inline bool Decimal::_internal_has_quantity() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Decimal::has_quantity() const {
  return _internal_has_quantity();
}
inline void Decimal::clear_quantity() {
  quantity_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Decimal::quantity() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Decimal.quantity)
  return _internal_quantity();
}
inline void Decimal::set_quantity(const std::string& value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Decimal.quantity)
}
inline std::string* Decimal::mutable_quantity() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Decimal.quantity)
  return _internal_mutable_quantity();
}
inline const std::string& Decimal::_internal_quantity() const {
  return quantity_.Get();
}
inline void Decimal::_internal_set_quantity(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  quantity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Decimal::set_quantity(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  quantity_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Decimal.quantity)
}
inline void Decimal::set_quantity(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  quantity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Decimal.quantity)
}
inline void Decimal::set_quantity(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  quantity_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Decimal.quantity)
}
inline std::string* Decimal::_internal_mutable_quantity() {
  _has_bits_[0] |= 0x00000004u;
  return quantity_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Decimal::release_quantity() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Decimal.quantity)
  if (!_internal_has_quantity()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return quantity_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Decimal::set_allocated_quantity(std::string* quantity) {
  if (quantity != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  quantity_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), quantity,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Decimal.quantity)
}

// optional string exponent = 5;
inline bool Decimal::_internal_has_exponent() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Decimal::has_exponent() const {
  return _internal_has_exponent();
}
inline void Decimal::clear_exponent() {
  exponent_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Decimal::exponent() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Decimal.exponent)
  return _internal_exponent();
}
inline void Decimal::set_exponent(const std::string& value) {
  _internal_set_exponent(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Decimal.exponent)
}
inline std::string* Decimal::mutable_exponent() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Decimal.exponent)
  return _internal_mutable_exponent();
}
inline const std::string& Decimal::_internal_exponent() const {
  return exponent_.Get();
}
inline void Decimal::_internal_set_exponent(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  exponent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Decimal::set_exponent(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  exponent_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Decimal.exponent)
}
inline void Decimal::set_exponent(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  exponent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Decimal.exponent)
}
inline void Decimal::set_exponent(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  exponent_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Decimal.exponent)
}
inline std::string* Decimal::_internal_mutable_exponent() {
  _has_bits_[0] |= 0x00000008u;
  return exponent_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Decimal::release_exponent() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Decimal.exponent)
  if (!_internal_has_exponent()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return exponent_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Decimal::set_allocated_exponent(std::string* exponent) {
  if (exponent != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  exponent_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), exponent,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Decimal.exponent)
}

// optional int32 style = 6 [deprecated = true];
inline bool Decimal::_internal_has_style() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Decimal::has_style() const {
  return _internal_has_style();
}
inline void Decimal::clear_style() {
  style_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Decimal::_internal_style() const {
  return style_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Decimal::style() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Decimal.style)
  return _internal_style();
}
inline void Decimal::_internal_set_style(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  style_ = value;
}
inline void Decimal::set_style(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_style(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Decimal.style)
}

// optional string morphosyntactic_features = 7;
inline bool Decimal::_internal_has_morphosyntactic_features() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Decimal::has_morphosyntactic_features() const {
  return _internal_has_morphosyntactic_features();
}
inline void Decimal::clear_morphosyntactic_features() {
  morphosyntactic_features_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Decimal::morphosyntactic_features() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Decimal.morphosyntactic_features)
  return _internal_morphosyntactic_features();
}
inline void Decimal::set_morphosyntactic_features(const std::string& value) {
  _internal_set_morphosyntactic_features(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Decimal.morphosyntactic_features)
}
inline std::string* Decimal::mutable_morphosyntactic_features() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Decimal.morphosyntactic_features)
  return _internal_mutable_morphosyntactic_features();
}
inline const std::string& Decimal::_internal_morphosyntactic_features() const {
  return morphosyntactic_features_.Get();
}
inline void Decimal::_internal_set_morphosyntactic_features(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Decimal::set_morphosyntactic_features(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  morphosyntactic_features_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Decimal.morphosyntactic_features)
}
inline void Decimal::set_morphosyntactic_features(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Decimal.morphosyntactic_features)
}
inline void Decimal::set_morphosyntactic_features(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000010u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Decimal.morphosyntactic_features)
}
inline std::string* Decimal::_internal_mutable_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000010u;
  return morphosyntactic_features_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Decimal::release_morphosyntactic_features() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Decimal.morphosyntactic_features)
  if (!_internal_has_morphosyntactic_features()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return morphosyntactic_features_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Decimal::set_allocated_morphosyntactic_features(std::string* morphosyntactic_features) {
  if (morphosyntactic_features != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  morphosyntactic_features_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), morphosyntactic_features,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Decimal.morphosyntactic_features)
}

// optional bool preserve_order = 8;
inline bool Decimal::_internal_has_preserve_order() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Decimal::has_preserve_order() const {
  return _internal_has_preserve_order();
}
inline void Decimal::clear_preserve_order() {
  preserve_order_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool Decimal::_internal_preserve_order() const {
  return preserve_order_;
}
inline bool Decimal::preserve_order() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Decimal.preserve_order)
  return _internal_preserve_order();
}
inline void Decimal::_internal_set_preserve_order(bool value) {
  _has_bits_[0] |= 0x00000080u;
  preserve_order_ = value;
}
inline void Decimal::set_preserve_order(bool value) {
  _internal_set_preserve_order(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Decimal.preserve_order)
}

// optional string code_switch = 9;
inline bool Decimal::_internal_has_code_switch() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Decimal::has_code_switch() const {
  return _internal_has_code_switch();
}
inline void Decimal::clear_code_switch() {
  code_switch_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& Decimal::code_switch() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Decimal.code_switch)
  return _internal_code_switch();
}
inline void Decimal::set_code_switch(const std::string& value) {
  _internal_set_code_switch(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Decimal.code_switch)
}
inline std::string* Decimal::mutable_code_switch() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Decimal.code_switch)
  return _internal_mutable_code_switch();
}
inline const std::string& Decimal::_internal_code_switch() const {
  return code_switch_.Get();
}
inline void Decimal::_internal_set_code_switch(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Decimal::set_code_switch(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  code_switch_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Decimal.code_switch)
}
inline void Decimal::set_code_switch(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Decimal.code_switch)
}
inline void Decimal::set_code_switch(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000020u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Decimal.code_switch)
}
inline std::string* Decimal::_internal_mutable_code_switch() {
  _has_bits_[0] |= 0x00000020u;
  return code_switch_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Decimal::release_code_switch() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Decimal.code_switch)
  if (!_internal_has_code_switch()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return code_switch_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Decimal::set_allocated_code_switch(std::string* code_switch) {
  if (code_switch != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  code_switch_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code_switch,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Decimal.code_switch)
}

// repeated string field_order = 10;
inline int Decimal::_internal_field_order_size() const {
  return field_order_.size();
}
inline int Decimal::field_order_size() const {
  return _internal_field_order_size();
}
inline void Decimal::clear_field_order() {
  field_order_.Clear();
}
inline std::string* Decimal::add_field_order() {
  // @@protoc_insertion_point(field_add_mutable:speech.sparrowhawk.Decimal.field_order)
  return _internal_add_field_order();
}
inline const std::string& Decimal::_internal_field_order(int index) const {
  return field_order_.Get(index);
}
inline const std::string& Decimal::field_order(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Decimal.field_order)
  return _internal_field_order(index);
}
inline std::string* Decimal::mutable_field_order(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Decimal.field_order)
  return field_order_.Mutable(index);
}
inline void Decimal::set_field_order(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Decimal.field_order)
  field_order_.Mutable(index)->assign(value);
}
inline void Decimal::set_field_order(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Decimal.field_order)
  field_order_.Mutable(index)->assign(std::move(value));
}
inline void Decimal::set_field_order(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  field_order_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Decimal.field_order)
}
inline void Decimal::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Decimal.field_order)
}
inline std::string* Decimal::_internal_add_field_order() {
  return field_order_.Add();
}
inline void Decimal::add_field_order(const std::string& value) {
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Decimal.field_order)
}
inline void Decimal::add_field_order(std::string&& value) {
  field_order_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Decimal.field_order)
}
inline void Decimal::add_field_order(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.sparrowhawk.Decimal.field_order)
}
inline void Decimal::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.sparrowhawk.Decimal.field_order)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Decimal::field_order() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.Decimal.field_order)
  return field_order_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Decimal::mutable_field_order() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.Decimal.field_order)
  return &field_order_;
}

// -------------------------------------------------------------------

// Measure

// optional .speech.sparrowhawk.Decimal decimal = 1;
inline bool Measure::_internal_has_decimal() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || decimal_ != nullptr);
  return value;
}
inline bool Measure::has_decimal() const {
  return _internal_has_decimal();
}
inline void Measure::clear_decimal() {
  if (decimal_ != nullptr) decimal_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::speech::sparrowhawk::Decimal& Measure::_internal_decimal() const {
  const ::speech::sparrowhawk::Decimal* p = decimal_;
  return p != nullptr ? *p : reinterpret_cast<const ::speech::sparrowhawk::Decimal&>(
      ::speech::sparrowhawk::_Decimal_default_instance_);
}
inline const ::speech::sparrowhawk::Decimal& Measure::decimal() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Measure.decimal)
  return _internal_decimal();
}
inline void Measure::unsafe_arena_set_allocated_decimal(
    ::speech::sparrowhawk::Decimal* decimal) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(decimal_);
  }
  decimal_ = decimal;
  if (decimal) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speech.sparrowhawk.Measure.decimal)
}
inline ::speech::sparrowhawk::Decimal* Measure::release_decimal() {
  _has_bits_[0] &= ~0x00000008u;
  ::speech::sparrowhawk::Decimal* temp = decimal_;
  decimal_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::speech::sparrowhawk::Decimal* Measure::unsafe_arena_release_decimal() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Measure.decimal)
  _has_bits_[0] &= ~0x00000008u;
  ::speech::sparrowhawk::Decimal* temp = decimal_;
  decimal_ = nullptr;
  return temp;
}
inline ::speech::sparrowhawk::Decimal* Measure::_internal_mutable_decimal() {
  _has_bits_[0] |= 0x00000008u;
  if (decimal_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::sparrowhawk::Decimal>(GetArena());
    decimal_ = p;
  }
  return decimal_;
}
inline ::speech::sparrowhawk::Decimal* Measure::mutable_decimal() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Measure.decimal)
  return _internal_mutable_decimal();
}
inline void Measure::set_allocated_decimal(::speech::sparrowhawk::Decimal* decimal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete decimal_;
  }
  if (decimal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(decimal);
    if (message_arena != submessage_arena) {
      decimal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, decimal, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  decimal_ = decimal;
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Measure.decimal)
}

// optional .speech.sparrowhawk.Fraction fraction = 2;
inline bool Measure::_internal_has_fraction() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || fraction_ != nullptr);
  return value;
}
inline bool Measure::has_fraction() const {
  return _internal_has_fraction();
}
inline void Measure::clear_fraction() {
  if (fraction_ != nullptr) fraction_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::speech::sparrowhawk::Fraction& Measure::_internal_fraction() const {
  const ::speech::sparrowhawk::Fraction* p = fraction_;
  return p != nullptr ? *p : reinterpret_cast<const ::speech::sparrowhawk::Fraction&>(
      ::speech::sparrowhawk::_Fraction_default_instance_);
}
inline const ::speech::sparrowhawk::Fraction& Measure::fraction() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Measure.fraction)
  return _internal_fraction();
}
inline void Measure::unsafe_arena_set_allocated_fraction(
    ::speech::sparrowhawk::Fraction* fraction) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(fraction_);
  }
  fraction_ = fraction;
  if (fraction) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speech.sparrowhawk.Measure.fraction)
}
inline ::speech::sparrowhawk::Fraction* Measure::release_fraction() {
  _has_bits_[0] &= ~0x00000010u;
  ::speech::sparrowhawk::Fraction* temp = fraction_;
  fraction_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::speech::sparrowhawk::Fraction* Measure::unsafe_arena_release_fraction() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Measure.fraction)
  _has_bits_[0] &= ~0x00000010u;
  ::speech::sparrowhawk::Fraction* temp = fraction_;
  fraction_ = nullptr;
  return temp;
}
inline ::speech::sparrowhawk::Fraction* Measure::_internal_mutable_fraction() {
  _has_bits_[0] |= 0x00000010u;
  if (fraction_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::sparrowhawk::Fraction>(GetArena());
    fraction_ = p;
  }
  return fraction_;
}
inline ::speech::sparrowhawk::Fraction* Measure::mutable_fraction() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Measure.fraction)
  return _internal_mutable_fraction();
}
inline void Measure::set_allocated_fraction(::speech::sparrowhawk::Fraction* fraction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete fraction_;
  }
  if (fraction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(fraction);
    if (message_arena != submessage_arena) {
      fraction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, fraction, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  fraction_ = fraction;
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Measure.fraction)
}

// optional .speech.sparrowhawk.Cardinal cardinal = 3;
inline bool Measure::_internal_has_cardinal() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || cardinal_ != nullptr);
  return value;
}
inline bool Measure::has_cardinal() const {
  return _internal_has_cardinal();
}
inline void Measure::clear_cardinal() {
  if (cardinal_ != nullptr) cardinal_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::speech::sparrowhawk::Cardinal& Measure::_internal_cardinal() const {
  const ::speech::sparrowhawk::Cardinal* p = cardinal_;
  return p != nullptr ? *p : reinterpret_cast<const ::speech::sparrowhawk::Cardinal&>(
      ::speech::sparrowhawk::_Cardinal_default_instance_);
}
inline const ::speech::sparrowhawk::Cardinal& Measure::cardinal() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Measure.cardinal)
  return _internal_cardinal();
}
inline void Measure::unsafe_arena_set_allocated_cardinal(
    ::speech::sparrowhawk::Cardinal* cardinal) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cardinal_);
  }
  cardinal_ = cardinal;
  if (cardinal) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speech.sparrowhawk.Measure.cardinal)
}
inline ::speech::sparrowhawk::Cardinal* Measure::release_cardinal() {
  _has_bits_[0] &= ~0x00000020u;
  ::speech::sparrowhawk::Cardinal* temp = cardinal_;
  cardinal_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::speech::sparrowhawk::Cardinal* Measure::unsafe_arena_release_cardinal() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Measure.cardinal)
  _has_bits_[0] &= ~0x00000020u;
  ::speech::sparrowhawk::Cardinal* temp = cardinal_;
  cardinal_ = nullptr;
  return temp;
}
inline ::speech::sparrowhawk::Cardinal* Measure::_internal_mutable_cardinal() {
  _has_bits_[0] |= 0x00000020u;
  if (cardinal_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::sparrowhawk::Cardinal>(GetArena());
    cardinal_ = p;
  }
  return cardinal_;
}
inline ::speech::sparrowhawk::Cardinal* Measure::mutable_cardinal() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Measure.cardinal)
  return _internal_mutable_cardinal();
}
inline void Measure::set_allocated_cardinal(::speech::sparrowhawk::Cardinal* cardinal) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete cardinal_;
  }
  if (cardinal) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(cardinal);
    if (message_arena != submessage_arena) {
      cardinal = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cardinal, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  cardinal_ = cardinal;
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Measure.cardinal)
}

// optional string units = 4;
inline bool Measure::_internal_has_units() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Measure::has_units() const {
  return _internal_has_units();
}
inline void Measure::clear_units() {
  units_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Measure::units() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Measure.units)
  return _internal_units();
}
inline void Measure::set_units(const std::string& value) {
  _internal_set_units(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Measure.units)
}
inline std::string* Measure::mutable_units() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Measure.units)
  return _internal_mutable_units();
}
inline const std::string& Measure::_internal_units() const {
  return units_.Get();
}
inline void Measure::_internal_set_units(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  units_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Measure::set_units(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  units_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Measure.units)
}
inline void Measure::set_units(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  units_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Measure.units)
}
inline void Measure::set_units(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  units_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Measure.units)
}
inline std::string* Measure::_internal_mutable_units() {
  _has_bits_[0] |= 0x00000001u;
  return units_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Measure::release_units() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Measure.units)
  if (!_internal_has_units()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return units_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Measure::set_allocated_units(std::string* units) {
  if (units != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  units_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), units,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Measure.units)
}

// optional int32 style = 5 [deprecated = true];
inline bool Measure::_internal_has_style() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Measure::has_style() const {
  return _internal_has_style();
}
inline void Measure::clear_style() {
  style_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Measure::_internal_style() const {
  return style_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Measure::style() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Measure.style)
  return _internal_style();
}
inline void Measure::_internal_set_style(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000040u;
  style_ = value;
}
inline void Measure::set_style(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_style(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Measure.style)
}

// optional string morphosyntactic_features = 6;
inline bool Measure::_internal_has_morphosyntactic_features() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Measure::has_morphosyntactic_features() const {
  return _internal_has_morphosyntactic_features();
}
inline void Measure::clear_morphosyntactic_features() {
  morphosyntactic_features_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Measure::morphosyntactic_features() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Measure.morphosyntactic_features)
  return _internal_morphosyntactic_features();
}
inline void Measure::set_morphosyntactic_features(const std::string& value) {
  _internal_set_morphosyntactic_features(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Measure.morphosyntactic_features)
}
inline std::string* Measure::mutable_morphosyntactic_features() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Measure.morphosyntactic_features)
  return _internal_mutable_morphosyntactic_features();
}
inline const std::string& Measure::_internal_morphosyntactic_features() const {
  return morphosyntactic_features_.Get();
}
inline void Measure::_internal_set_morphosyntactic_features(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Measure::set_morphosyntactic_features(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  morphosyntactic_features_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Measure.morphosyntactic_features)
}
inline void Measure::set_morphosyntactic_features(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Measure.morphosyntactic_features)
}
inline void Measure::set_morphosyntactic_features(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Measure.morphosyntactic_features)
}
inline std::string* Measure::_internal_mutable_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000002u;
  return morphosyntactic_features_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Measure::release_morphosyntactic_features() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Measure.morphosyntactic_features)
  if (!_internal_has_morphosyntactic_features()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return morphosyntactic_features_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Measure::set_allocated_morphosyntactic_features(std::string* morphosyntactic_features) {
  if (morphosyntactic_features != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  morphosyntactic_features_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), morphosyntactic_features,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Measure.morphosyntactic_features)
}

// optional bool preserve_order = 7;
inline bool Measure::_internal_has_preserve_order() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Measure::has_preserve_order() const {
  return _internal_has_preserve_order();
}
inline void Measure::clear_preserve_order() {
  preserve_order_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool Measure::_internal_preserve_order() const {
  return preserve_order_;
}
inline bool Measure::preserve_order() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Measure.preserve_order)
  return _internal_preserve_order();
}
inline void Measure::_internal_set_preserve_order(bool value) {
  _has_bits_[0] |= 0x00000080u;
  preserve_order_ = value;
}
inline void Measure::set_preserve_order(bool value) {
  _internal_set_preserve_order(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Measure.preserve_order)
}

// optional string code_switch = 8;
inline bool Measure::_internal_has_code_switch() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Measure::has_code_switch() const {
  return _internal_has_code_switch();
}
inline void Measure::clear_code_switch() {
  code_switch_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Measure::code_switch() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Measure.code_switch)
  return _internal_code_switch();
}
inline void Measure::set_code_switch(const std::string& value) {
  _internal_set_code_switch(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Measure.code_switch)
}
inline std::string* Measure::mutable_code_switch() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Measure.code_switch)
  return _internal_mutable_code_switch();
}
inline const std::string& Measure::_internal_code_switch() const {
  return code_switch_.Get();
}
inline void Measure::_internal_set_code_switch(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Measure::set_code_switch(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  code_switch_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Measure.code_switch)
}
inline void Measure::set_code_switch(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Measure.code_switch)
}
inline void Measure::set_code_switch(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Measure.code_switch)
}
inline std::string* Measure::_internal_mutable_code_switch() {
  _has_bits_[0] |= 0x00000004u;
  return code_switch_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Measure::release_code_switch() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Measure.code_switch)
  if (!_internal_has_code_switch()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return code_switch_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Measure::set_allocated_code_switch(std::string* code_switch) {
  if (code_switch != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  code_switch_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code_switch,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Measure.code_switch)
}

// repeated string field_order = 9;
inline int Measure::_internal_field_order_size() const {
  return field_order_.size();
}
inline int Measure::field_order_size() const {
  return _internal_field_order_size();
}
inline void Measure::clear_field_order() {
  field_order_.Clear();
}
inline std::string* Measure::add_field_order() {
  // @@protoc_insertion_point(field_add_mutable:speech.sparrowhawk.Measure.field_order)
  return _internal_add_field_order();
}
inline const std::string& Measure::_internal_field_order(int index) const {
  return field_order_.Get(index);
}
inline const std::string& Measure::field_order(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Measure.field_order)
  return _internal_field_order(index);
}
inline std::string* Measure::mutable_field_order(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Measure.field_order)
  return field_order_.Mutable(index);
}
inline void Measure::set_field_order(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Measure.field_order)
  field_order_.Mutable(index)->assign(value);
}
inline void Measure::set_field_order(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Measure.field_order)
  field_order_.Mutable(index)->assign(std::move(value));
}
inline void Measure::set_field_order(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  field_order_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Measure.field_order)
}
inline void Measure::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Measure.field_order)
}
inline std::string* Measure::_internal_add_field_order() {
  return field_order_.Add();
}
inline void Measure::add_field_order(const std::string& value) {
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Measure.field_order)
}
inline void Measure::add_field_order(std::string&& value) {
  field_order_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Measure.field_order)
}
inline void Measure::add_field_order(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.sparrowhawk.Measure.field_order)
}
inline void Measure::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.sparrowhawk.Measure.field_order)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Measure::field_order() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.Measure.field_order)
  return field_order_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Measure::mutable_field_order() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.Measure.field_order)
  return &field_order_;
}

// -------------------------------------------------------------------

// Date

// optional string weekday = 1;
inline bool Date::_internal_has_weekday() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Date::has_weekday() const {
  return _internal_has_weekday();
}
inline void Date::clear_weekday() {
  weekday_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Date::weekday() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Date.weekday)
  return _internal_weekday();
}
inline void Date::set_weekday(const std::string& value) {
  _internal_set_weekday(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.weekday)
}
inline std::string* Date::mutable_weekday() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Date.weekday)
  return _internal_mutable_weekday();
}
inline const std::string& Date::_internal_weekday() const {
  return weekday_.Get();
}
inline void Date::_internal_set_weekday(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  weekday_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Date::set_weekday(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  weekday_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Date.weekday)
}
inline void Date::set_weekday(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  weekday_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Date.weekday)
}
inline void Date::set_weekday(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  weekday_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Date.weekday)
}
inline std::string* Date::_internal_mutable_weekday() {
  _has_bits_[0] |= 0x00000001u;
  return weekday_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Date::release_weekday() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Date.weekday)
  if (!_internal_has_weekday()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return weekday_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Date::set_allocated_weekday(std::string* weekday) {
  if (weekday != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  weekday_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), weekday,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Date.weekday)
}

// optional string day = 2;
inline bool Date::_internal_has_day() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Date::has_day() const {
  return _internal_has_day();
}
inline void Date::clear_day() {
  day_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Date::day() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Date.day)
  return _internal_day();
}
inline void Date::set_day(const std::string& value) {
  _internal_set_day(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.day)
}
inline std::string* Date::mutable_day() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Date.day)
  return _internal_mutable_day();
}
inline const std::string& Date::_internal_day() const {
  return day_.Get();
}
inline void Date::_internal_set_day(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  day_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Date::set_day(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  day_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Date.day)
}
inline void Date::set_day(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  day_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Date.day)
}
inline void Date::set_day(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  day_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Date.day)
}
inline std::string* Date::_internal_mutable_day() {
  _has_bits_[0] |= 0x00000002u;
  return day_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Date::release_day() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Date.day)
  if (!_internal_has_day()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return day_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Date::set_allocated_day(std::string* day) {
  if (day != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  day_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), day,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Date.day)
}

// optional string month = 3;
inline bool Date::_internal_has_month() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Date::has_month() const {
  return _internal_has_month();
}
inline void Date::clear_month() {
  month_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Date::month() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Date.month)
  return _internal_month();
}
inline void Date::set_month(const std::string& value) {
  _internal_set_month(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.month)
}
inline std::string* Date::mutable_month() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Date.month)
  return _internal_mutable_month();
}
inline const std::string& Date::_internal_month() const {
  return month_.Get();
}
inline void Date::_internal_set_month(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  month_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Date::set_month(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  month_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Date.month)
}
inline void Date::set_month(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  month_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Date.month)
}
inline void Date::set_month(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  month_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Date.month)
}
inline std::string* Date::_internal_mutable_month() {
  _has_bits_[0] |= 0x00000004u;
  return month_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Date::release_month() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Date.month)
  if (!_internal_has_month()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return month_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Date::set_allocated_month(std::string* month) {
  if (month != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  month_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), month,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Date.month)
}

// optional string year = 4;
inline bool Date::_internal_has_year() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Date::has_year() const {
  return _internal_has_year();
}
inline void Date::clear_year() {
  year_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Date::year() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Date.year)
  return _internal_year();
}
inline void Date::set_year(const std::string& value) {
  _internal_set_year(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.year)
}
inline std::string* Date::mutable_year() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Date.year)
  return _internal_mutable_year();
}
inline const std::string& Date::_internal_year() const {
  return year_.Get();
}
inline void Date::_internal_set_year(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  year_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Date::set_year(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  year_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Date.year)
}
inline void Date::set_year(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  year_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Date.year)
}
inline void Date::set_year(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  year_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Date.year)
}
inline std::string* Date::_internal_mutable_year() {
  _has_bits_[0] |= 0x00000008u;
  return year_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Date::release_year() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Date.year)
  if (!_internal_has_year()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return year_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Date::set_allocated_year(std::string* year) {
  if (year != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  year_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), year,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Date.year)
}

// optional int32 style = 5 [deprecated = true];
inline bool Date::_internal_has_style() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Date::has_style() const {
  return _internal_has_style();
}
inline void Date::clear_style() {
  style_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Date::_internal_style() const {
  return style_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Date::style() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Date.style)
  return _internal_style();
}
inline void Date::_internal_set_style(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  style_ = value;
}
inline void Date::set_style(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_style(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.style)
}

// optional string text = 6 [deprecated = true];
inline bool Date::_internal_has_text() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Date::has_text() const {
  return _internal_has_text();
}
inline void Date::clear_text() {
  text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Date::text() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Date.text)
  return _internal_text();
}
inline void Date::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.text)
}
inline std::string* Date::mutable_text() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Date.text)
  return _internal_mutable_text();
}
inline const std::string& Date::_internal_text() const {
  return text_.Get();
}
inline void Date::_internal_set_text(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Date::set_text(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  text_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Date.text)
}
inline void Date::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Date.text)
}
inline void Date::set_text(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000010u;
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Date.text)
}
inline std::string* Date::_internal_mutable_text() {
  _has_bits_[0] |= 0x00000010u;
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Date::release_text() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Date.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return text_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Date::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Date.text)
}

// optional bool short_year = 7 [deprecated = true];
inline bool Date::_internal_has_short_year() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Date::has_short_year() const {
  return _internal_has_short_year();
}
inline void Date::clear_short_year() {
  short_year_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool Date::_internal_short_year() const {
  return short_year_;
}
inline bool Date::short_year() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Date.short_year)
  return _internal_short_year();
}
inline void Date::_internal_set_short_year(bool value) {
  _has_bits_[0] |= 0x00000200u;
  short_year_ = value;
}
inline void Date::set_short_year(bool value) {
  _internal_set_short_year(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.short_year)
}

// optional string era = 8;
inline bool Date::_internal_has_era() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Date::has_era() const {
  return _internal_has_era();
}
inline void Date::clear_era() {
  era_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& Date::era() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Date.era)
  return _internal_era();
}
inline void Date::set_era(const std::string& value) {
  _internal_set_era(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.era)
}
inline std::string* Date::mutable_era() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Date.era)
  return _internal_mutable_era();
}
inline const std::string& Date::_internal_era() const {
  return era_.Get();
}
inline void Date::_internal_set_era(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  era_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Date::set_era(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  era_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Date.era)
}
inline void Date::set_era(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  era_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Date.era)
}
inline void Date::set_era(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000020u;
  era_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Date.era)
}
inline std::string* Date::_internal_mutable_era() {
  _has_bits_[0] |= 0x00000020u;
  return era_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Date::release_era() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Date.era)
  if (!_internal_has_era()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return era_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Date::set_allocated_era(std::string* era) {
  if (era != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  era_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), era,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Date.era)
}

// optional string morphosyntactic_features = 9;
inline bool Date::_internal_has_morphosyntactic_features() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Date::has_morphosyntactic_features() const {
  return _internal_has_morphosyntactic_features();
}
inline void Date::clear_morphosyntactic_features() {
  morphosyntactic_features_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& Date::morphosyntactic_features() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Date.morphosyntactic_features)
  return _internal_morphosyntactic_features();
}
inline void Date::set_morphosyntactic_features(const std::string& value) {
  _internal_set_morphosyntactic_features(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.morphosyntactic_features)
}
inline std::string* Date::mutable_morphosyntactic_features() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Date.morphosyntactic_features)
  return _internal_mutable_morphosyntactic_features();
}
inline const std::string& Date::_internal_morphosyntactic_features() const {
  return morphosyntactic_features_.Get();
}
inline void Date::_internal_set_morphosyntactic_features(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Date::set_morphosyntactic_features(std::string&& value) {
  _has_bits_[0] |= 0x00000040u;
  morphosyntactic_features_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Date.morphosyntactic_features)
}
inline void Date::set_morphosyntactic_features(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000040u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Date.morphosyntactic_features)
}
inline void Date::set_morphosyntactic_features(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000040u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Date.morphosyntactic_features)
}
inline std::string* Date::_internal_mutable_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000040u;
  return morphosyntactic_features_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Date::release_morphosyntactic_features() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Date.morphosyntactic_features)
  if (!_internal_has_morphosyntactic_features()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return morphosyntactic_features_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Date::set_allocated_morphosyntactic_features(std::string* morphosyntactic_features) {
  if (morphosyntactic_features != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  morphosyntactic_features_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), morphosyntactic_features,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Date.morphosyntactic_features)
}

// optional bool preserve_order = 10;
inline bool Date::_internal_has_preserve_order() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Date::has_preserve_order() const {
  return _internal_has_preserve_order();
}
inline void Date::clear_preserve_order() {
  preserve_order_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool Date::_internal_preserve_order() const {
  return preserve_order_;
}
inline bool Date::preserve_order() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Date.preserve_order)
  return _internal_preserve_order();
}
inline void Date::_internal_set_preserve_order(bool value) {
  _has_bits_[0] |= 0x00000400u;
  preserve_order_ = value;
}
inline void Date::set_preserve_order(bool value) {
  _internal_set_preserve_order(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.preserve_order)
}

// optional string code_switch = 11;
inline bool Date::_internal_has_code_switch() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Date::has_code_switch() const {
  return _internal_has_code_switch();
}
inline void Date::clear_code_switch() {
  code_switch_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& Date::code_switch() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Date.code_switch)
  return _internal_code_switch();
}
inline void Date::set_code_switch(const std::string& value) {
  _internal_set_code_switch(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.code_switch)
}
inline std::string* Date::mutable_code_switch() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Date.code_switch)
  return _internal_mutable_code_switch();
}
inline const std::string& Date::_internal_code_switch() const {
  return code_switch_.Get();
}
inline void Date::_internal_set_code_switch(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Date::set_code_switch(std::string&& value) {
  _has_bits_[0] |= 0x00000080u;
  code_switch_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Date.code_switch)
}
inline void Date::set_code_switch(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000080u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Date.code_switch)
}
inline void Date::set_code_switch(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000080u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Date.code_switch)
}
inline std::string* Date::_internal_mutable_code_switch() {
  _has_bits_[0] |= 0x00000080u;
  return code_switch_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Date::release_code_switch() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Date.code_switch)
  if (!_internal_has_code_switch()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return code_switch_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Date::set_allocated_code_switch(std::string* code_switch) {
  if (code_switch != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  code_switch_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code_switch,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Date.code_switch)
}

// repeated string field_order = 12;
inline int Date::_internal_field_order_size() const {
  return field_order_.size();
}
inline int Date::field_order_size() const {
  return _internal_field_order_size();
}
inline void Date::clear_field_order() {
  field_order_.Clear();
}
inline std::string* Date::add_field_order() {
  // @@protoc_insertion_point(field_add_mutable:speech.sparrowhawk.Date.field_order)
  return _internal_add_field_order();
}
inline const std::string& Date::_internal_field_order(int index) const {
  return field_order_.Get(index);
}
inline const std::string& Date::field_order(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Date.field_order)
  return _internal_field_order(index);
}
inline std::string* Date::mutable_field_order(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Date.field_order)
  return field_order_.Mutable(index);
}
inline void Date::set_field_order(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.field_order)
  field_order_.Mutable(index)->assign(value);
}
inline void Date::set_field_order(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Date.field_order)
  field_order_.Mutable(index)->assign(std::move(value));
}
inline void Date::set_field_order(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  field_order_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Date.field_order)
}
inline void Date::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Date.field_order)
}
inline std::string* Date::_internal_add_field_order() {
  return field_order_.Add();
}
inline void Date::add_field_order(const std::string& value) {
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Date.field_order)
}
inline void Date::add_field_order(std::string&& value) {
  field_order_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Date.field_order)
}
inline void Date::add_field_order(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.sparrowhawk.Date.field_order)
}
inline void Date::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.sparrowhawk.Date.field_order)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Date::field_order() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.Date.field_order)
  return field_order_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Date::mutable_field_order() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.Date.field_order)
  return &field_order_;
}

// -------------------------------------------------------------------

// Money

// required .speech.sparrowhawk.Decimal amount = 1;
inline bool Money::_internal_has_amount() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || amount_ != nullptr);
  return value;
}
inline bool Money::has_amount() const {
  return _internal_has_amount();
}
inline void Money::clear_amount() {
  if (amount_ != nullptr) amount_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::speech::sparrowhawk::Decimal& Money::_internal_amount() const {
  const ::speech::sparrowhawk::Decimal* p = amount_;
  return p != nullptr ? *p : reinterpret_cast<const ::speech::sparrowhawk::Decimal&>(
      ::speech::sparrowhawk::_Decimal_default_instance_);
}
inline const ::speech::sparrowhawk::Decimal& Money::amount() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Money.amount)
  return _internal_amount();
}
inline void Money::unsafe_arena_set_allocated_amount(
    ::speech::sparrowhawk::Decimal* amount) {
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(amount_);
  }
  amount_ = amount;
  if (amount) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:speech.sparrowhawk.Money.amount)
}
inline ::speech::sparrowhawk::Decimal* Money::release_amount() {
  _has_bits_[0] &= ~0x00000008u;
  ::speech::sparrowhawk::Decimal* temp = amount_;
  amount_ = nullptr;
  if (GetArena() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
  return temp;
}
inline ::speech::sparrowhawk::Decimal* Money::unsafe_arena_release_amount() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Money.amount)
  _has_bits_[0] &= ~0x00000008u;
  ::speech::sparrowhawk::Decimal* temp = amount_;
  amount_ = nullptr;
  return temp;
}
inline ::speech::sparrowhawk::Decimal* Money::_internal_mutable_amount() {
  _has_bits_[0] |= 0x00000008u;
  if (amount_ == nullptr) {
    auto* p = CreateMaybeMessage<::speech::sparrowhawk::Decimal>(GetArena());
    amount_ = p;
  }
  return amount_;
}
inline ::speech::sparrowhawk::Decimal* Money::mutable_amount() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Money.amount)
  return _internal_mutable_amount();
}
inline void Money::set_allocated_amount(::speech::sparrowhawk::Decimal* amount) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArena();
  if (message_arena == nullptr) {
    delete amount_;
  }
  if (amount) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::GetArena(amount);
    if (message_arena != submessage_arena) {
      amount = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, amount, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  amount_ = amount;
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Money.amount)
}

// optional int64 quantity = 2;
inline bool Money::_internal_has_quantity() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Money::has_quantity() const {
  return _internal_has_quantity();
}
inline void Money::clear_quantity() {
  quantity_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Money::_internal_quantity() const {
  return quantity_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Money::quantity() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Money.quantity)
  return _internal_quantity();
}
inline void Money::_internal_set_quantity(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _has_bits_[0] |= 0x00000010u;
  quantity_ = value;
}
inline void Money::set_quantity(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_quantity(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Money.quantity)
}

// required string currency = 3;
inline bool Money::_internal_has_currency() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Money::has_currency() const {
  return _internal_has_currency();
}
inline void Money::clear_currency() {
  currency_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Money::currency() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Money.currency)
  return _internal_currency();
}
inline void Money::set_currency(const std::string& value) {
  _internal_set_currency(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Money.currency)
}
inline std::string* Money::mutable_currency() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Money.currency)
  return _internal_mutable_currency();
}
inline const std::string& Money::_internal_currency() const {
  return currency_.Get();
}
inline void Money::_internal_set_currency(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  currency_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Money::set_currency(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  currency_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Money.currency)
}
inline void Money::set_currency(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  currency_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Money.currency)
}
inline void Money::set_currency(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  currency_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Money.currency)
}
inline std::string* Money::_internal_mutable_currency() {
  _has_bits_[0] |= 0x00000001u;
  return currency_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Money::release_currency() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Money.currency)
  if (!_internal_has_currency()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return currency_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Money::set_allocated_currency(std::string* currency) {
  if (currency != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  currency_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), currency,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Money.currency)
}

// optional int32 style = 4 [deprecated = true];
inline bool Money::_internal_has_style() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Money::has_style() const {
  return _internal_has_style();
}
inline void Money::clear_style() {
  style_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Money::_internal_style() const {
  return style_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Money::style() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Money.style)
  return _internal_style();
}
inline void Money::_internal_set_style(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000020u;
  style_ = value;
}
inline void Money::set_style(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_style(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Money.style)
}

// optional string morphosyntactic_features = 5;
inline bool Money::_internal_has_morphosyntactic_features() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Money::has_morphosyntactic_features() const {
  return _internal_has_morphosyntactic_features();
}
inline void Money::clear_morphosyntactic_features() {
  morphosyntactic_features_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Money::morphosyntactic_features() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Money.morphosyntactic_features)
  return _internal_morphosyntactic_features();
}
inline void Money::set_morphosyntactic_features(const std::string& value) {
  _internal_set_morphosyntactic_features(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Money.morphosyntactic_features)
}
inline std::string* Money::mutable_morphosyntactic_features() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Money.morphosyntactic_features)
  return _internal_mutable_morphosyntactic_features();
}
inline const std::string& Money::_internal_morphosyntactic_features() const {
  return morphosyntactic_features_.Get();
}
inline void Money::_internal_set_morphosyntactic_features(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Money::set_morphosyntactic_features(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  morphosyntactic_features_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Money.morphosyntactic_features)
}
inline void Money::set_morphosyntactic_features(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Money.morphosyntactic_features)
}
inline void Money::set_morphosyntactic_features(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Money.morphosyntactic_features)
}
inline std::string* Money::_internal_mutable_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000002u;
  return morphosyntactic_features_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Money::release_morphosyntactic_features() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Money.morphosyntactic_features)
  if (!_internal_has_morphosyntactic_features()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return morphosyntactic_features_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Money::set_allocated_morphosyntactic_features(std::string* morphosyntactic_features) {
  if (morphosyntactic_features != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  morphosyntactic_features_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), morphosyntactic_features,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Money.morphosyntactic_features)
}

// optional bool preserve_order = 6;
inline bool Money::_internal_has_preserve_order() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Money::has_preserve_order() const {
  return _internal_has_preserve_order();
}
inline void Money::clear_preserve_order() {
  preserve_order_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool Money::_internal_preserve_order() const {
  return preserve_order_;
}
inline bool Money::preserve_order() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Money.preserve_order)
  return _internal_preserve_order();
}
inline void Money::_internal_set_preserve_order(bool value) {
  _has_bits_[0] |= 0x00000040u;
  preserve_order_ = value;
}
inline void Money::set_preserve_order(bool value) {
  _internal_set_preserve_order(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Money.preserve_order)
}

// optional string code_switch = 7;
inline bool Money::_internal_has_code_switch() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Money::has_code_switch() const {
  return _internal_has_code_switch();
}
inline void Money::clear_code_switch() {
  code_switch_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Money::code_switch() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Money.code_switch)
  return _internal_code_switch();
}
inline void Money::set_code_switch(const std::string& value) {
  _internal_set_code_switch(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Money.code_switch)
}
inline std::string* Money::mutable_code_switch() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Money.code_switch)
  return _internal_mutable_code_switch();
}
inline const std::string& Money::_internal_code_switch() const {
  return code_switch_.Get();
}
inline void Money::_internal_set_code_switch(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Money::set_code_switch(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  code_switch_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Money.code_switch)
}
inline void Money::set_code_switch(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Money.code_switch)
}
inline void Money::set_code_switch(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Money.code_switch)
}
inline std::string* Money::_internal_mutable_code_switch() {
  _has_bits_[0] |= 0x00000004u;
  return code_switch_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Money::release_code_switch() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Money.code_switch)
  if (!_internal_has_code_switch()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return code_switch_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Money::set_allocated_code_switch(std::string* code_switch) {
  if (code_switch != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  code_switch_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code_switch,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Money.code_switch)
}

// repeated string field_order = 8;
inline int Money::_internal_field_order_size() const {
  return field_order_.size();
}
inline int Money::field_order_size() const {
  return _internal_field_order_size();
}
inline void Money::clear_field_order() {
  field_order_.Clear();
}
inline std::string* Money::add_field_order() {
  // @@protoc_insertion_point(field_add_mutable:speech.sparrowhawk.Money.field_order)
  return _internal_add_field_order();
}
inline const std::string& Money::_internal_field_order(int index) const {
  return field_order_.Get(index);
}
inline const std::string& Money::field_order(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Money.field_order)
  return _internal_field_order(index);
}
inline std::string* Money::mutable_field_order(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Money.field_order)
  return field_order_.Mutable(index);
}
inline void Money::set_field_order(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Money.field_order)
  field_order_.Mutable(index)->assign(value);
}
inline void Money::set_field_order(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Money.field_order)
  field_order_.Mutable(index)->assign(std::move(value));
}
inline void Money::set_field_order(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  field_order_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Money.field_order)
}
inline void Money::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Money.field_order)
}
inline std::string* Money::_internal_add_field_order() {
  return field_order_.Add();
}
inline void Money::add_field_order(const std::string& value) {
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Money.field_order)
}
inline void Money::add_field_order(std::string&& value) {
  field_order_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Money.field_order)
}
inline void Money::add_field_order(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.sparrowhawk.Money.field_order)
}
inline void Money::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.sparrowhawk.Money.field_order)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Money::field_order() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.Money.field_order)
  return field_order_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Money::mutable_field_order() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.Money.field_order)
  return &field_order_;
}

// -------------------------------------------------------------------

// Telephone

// optional string country_code = 1;
inline bool Telephone::_internal_has_country_code() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Telephone::has_country_code() const {
  return _internal_has_country_code();
}
inline void Telephone::clear_country_code() {
  country_code_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Telephone::country_code() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Telephone.country_code)
  return _internal_country_code();
}
inline void Telephone::set_country_code(const std::string& value) {
  _internal_set_country_code(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Telephone.country_code)
}
inline std::string* Telephone::mutable_country_code() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Telephone.country_code)
  return _internal_mutable_country_code();
}
inline const std::string& Telephone::_internal_country_code() const {
  return country_code_.Get();
}
inline void Telephone::_internal_set_country_code(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  country_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Telephone::set_country_code(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  country_code_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Telephone.country_code)
}
inline void Telephone::set_country_code(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  country_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Telephone.country_code)
}
inline void Telephone::set_country_code(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  country_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Telephone.country_code)
}
inline std::string* Telephone::_internal_mutable_country_code() {
  _has_bits_[0] |= 0x00000001u;
  return country_code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Telephone::release_country_code() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Telephone.country_code)
  if (!_internal_has_country_code()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return country_code_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Telephone::set_allocated_country_code(std::string* country_code) {
  if (country_code != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  country_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), country_code,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Telephone.country_code)
}

// repeated string number_part = 2;
inline int Telephone::_internal_number_part_size() const {
  return number_part_.size();
}
inline int Telephone::number_part_size() const {
  return _internal_number_part_size();
}
inline void Telephone::clear_number_part() {
  number_part_.Clear();
}
inline std::string* Telephone::add_number_part() {
  // @@protoc_insertion_point(field_add_mutable:speech.sparrowhawk.Telephone.number_part)
  return _internal_add_number_part();
}
inline const std::string& Telephone::_internal_number_part(int index) const {
  return number_part_.Get(index);
}
inline const std::string& Telephone::number_part(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Telephone.number_part)
  return _internal_number_part(index);
}
inline std::string* Telephone::mutable_number_part(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Telephone.number_part)
  return number_part_.Mutable(index);
}
inline void Telephone::set_number_part(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Telephone.number_part)
  number_part_.Mutable(index)->assign(value);
}
inline void Telephone::set_number_part(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Telephone.number_part)
  number_part_.Mutable(index)->assign(std::move(value));
}
inline void Telephone::set_number_part(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  number_part_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Telephone.number_part)
}
inline void Telephone::set_number_part(int index, const char* value, size_t size) {
  number_part_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Telephone.number_part)
}
inline std::string* Telephone::_internal_add_number_part() {
  return number_part_.Add();
}
inline void Telephone::add_number_part(const std::string& value) {
  number_part_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Telephone.number_part)
}
inline void Telephone::add_number_part(std::string&& value) {
  number_part_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Telephone.number_part)
}
inline void Telephone::add_number_part(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  number_part_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.sparrowhawk.Telephone.number_part)
}
inline void Telephone::add_number_part(const char* value, size_t size) {
  number_part_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.sparrowhawk.Telephone.number_part)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Telephone::number_part() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.Telephone.number_part)
  return number_part_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Telephone::mutable_number_part() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.Telephone.number_part)
  return &number_part_;
}

// optional string extension = 3;
inline bool Telephone::_internal_has_extension() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Telephone::has_extension() const {
  return _internal_has_extension();
}
inline void Telephone::clear_extension() {
  extension_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Telephone::extension() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Telephone.extension)
  return _internal_extension();
}
inline void Telephone::set_extension(const std::string& value) {
  _internal_set_extension(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Telephone.extension)
}
inline std::string* Telephone::mutable_extension() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Telephone.extension)
  return _internal_mutable_extension();
}
inline const std::string& Telephone::_internal_extension() const {
  return extension_.Get();
}
inline void Telephone::_internal_set_extension(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  extension_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Telephone::set_extension(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  extension_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Telephone.extension)
}
inline void Telephone::set_extension(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  extension_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Telephone.extension)
}
inline void Telephone::set_extension(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  extension_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Telephone.extension)
}
inline std::string* Telephone::_internal_mutable_extension() {
  _has_bits_[0] |= 0x00000002u;
  return extension_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Telephone::release_extension() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Telephone.extension)
  if (!_internal_has_extension()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return extension_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Telephone::set_allocated_extension(std::string* extension) {
  if (extension != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  extension_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), extension,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Telephone.extension)
}

// optional int32 style = 4 [deprecated = true];
inline bool Telephone::_internal_has_style() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Telephone::has_style() const {
  return _internal_has_style();
}
inline void Telephone::clear_style() {
  style_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Telephone::_internal_style() const {
  return style_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Telephone::style() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Telephone.style)
  return _internal_style();
}
inline void Telephone::_internal_set_style(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  style_ = value;
}
inline void Telephone::set_style(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_style(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Telephone.style)
}

// optional string morphosyntactic_features = 5;
inline bool Telephone::_internal_has_morphosyntactic_features() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Telephone::has_morphosyntactic_features() const {
  return _internal_has_morphosyntactic_features();
}
inline void Telephone::clear_morphosyntactic_features() {
  morphosyntactic_features_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Telephone::morphosyntactic_features() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Telephone.morphosyntactic_features)
  return _internal_morphosyntactic_features();
}
inline void Telephone::set_morphosyntactic_features(const std::string& value) {
  _internal_set_morphosyntactic_features(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Telephone.morphosyntactic_features)
}
inline std::string* Telephone::mutable_morphosyntactic_features() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Telephone.morphosyntactic_features)
  return _internal_mutable_morphosyntactic_features();
}
inline const std::string& Telephone::_internal_morphosyntactic_features() const {
  return morphosyntactic_features_.Get();
}
inline void Telephone::_internal_set_morphosyntactic_features(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Telephone::set_morphosyntactic_features(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  morphosyntactic_features_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Telephone.morphosyntactic_features)
}
inline void Telephone::set_morphosyntactic_features(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Telephone.morphosyntactic_features)
}
inline void Telephone::set_morphosyntactic_features(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Telephone.morphosyntactic_features)
}
inline std::string* Telephone::_internal_mutable_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000004u;
  return morphosyntactic_features_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Telephone::release_morphosyntactic_features() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Telephone.morphosyntactic_features)
  if (!_internal_has_morphosyntactic_features()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return morphosyntactic_features_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Telephone::set_allocated_morphosyntactic_features(std::string* morphosyntactic_features) {
  if (morphosyntactic_features != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  morphosyntactic_features_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), morphosyntactic_features,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Telephone.morphosyntactic_features)
}

// optional bool preserve_order = 6;
inline bool Telephone::_internal_has_preserve_order() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Telephone::has_preserve_order() const {
  return _internal_has_preserve_order();
}
inline void Telephone::clear_preserve_order() {
  preserve_order_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool Telephone::_internal_preserve_order() const {
  return preserve_order_;
}
inline bool Telephone::preserve_order() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Telephone.preserve_order)
  return _internal_preserve_order();
}
inline void Telephone::_internal_set_preserve_order(bool value) {
  _has_bits_[0] |= 0x00000020u;
  preserve_order_ = value;
}
inline void Telephone::set_preserve_order(bool value) {
  _internal_set_preserve_order(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Telephone.preserve_order)
}

// optional string code_switch = 7;
inline bool Telephone::_internal_has_code_switch() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Telephone::has_code_switch() const {
  return _internal_has_code_switch();
}
inline void Telephone::clear_code_switch() {
  code_switch_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Telephone::code_switch() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Telephone.code_switch)
  return _internal_code_switch();
}
inline void Telephone::set_code_switch(const std::string& value) {
  _internal_set_code_switch(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Telephone.code_switch)
}
inline std::string* Telephone::mutable_code_switch() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Telephone.code_switch)
  return _internal_mutable_code_switch();
}
inline const std::string& Telephone::_internal_code_switch() const {
  return code_switch_.Get();
}
inline void Telephone::_internal_set_code_switch(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Telephone::set_code_switch(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  code_switch_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Telephone.code_switch)
}
inline void Telephone::set_code_switch(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Telephone.code_switch)
}
inline void Telephone::set_code_switch(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Telephone.code_switch)
}
inline std::string* Telephone::_internal_mutable_code_switch() {
  _has_bits_[0] |= 0x00000008u;
  return code_switch_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Telephone::release_code_switch() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Telephone.code_switch)
  if (!_internal_has_code_switch()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return code_switch_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Telephone::set_allocated_code_switch(std::string* code_switch) {
  if (code_switch != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  code_switch_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code_switch,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Telephone.code_switch)
}

// repeated string field_order = 8;
inline int Telephone::_internal_field_order_size() const {
  return field_order_.size();
}
inline int Telephone::field_order_size() const {
  return _internal_field_order_size();
}
inline void Telephone::clear_field_order() {
  field_order_.Clear();
}
inline std::string* Telephone::add_field_order() {
  // @@protoc_insertion_point(field_add_mutable:speech.sparrowhawk.Telephone.field_order)
  return _internal_add_field_order();
}
inline const std::string& Telephone::_internal_field_order(int index) const {
  return field_order_.Get(index);
}
inline const std::string& Telephone::field_order(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Telephone.field_order)
  return _internal_field_order(index);
}
inline std::string* Telephone::mutable_field_order(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Telephone.field_order)
  return field_order_.Mutable(index);
}
inline void Telephone::set_field_order(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Telephone.field_order)
  field_order_.Mutable(index)->assign(value);
}
inline void Telephone::set_field_order(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Telephone.field_order)
  field_order_.Mutable(index)->assign(std::move(value));
}
inline void Telephone::set_field_order(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  field_order_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Telephone.field_order)
}
inline void Telephone::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Telephone.field_order)
}
inline std::string* Telephone::_internal_add_field_order() {
  return field_order_.Add();
}
inline void Telephone::add_field_order(const std::string& value) {
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Telephone.field_order)
}
inline void Telephone::add_field_order(std::string&& value) {
  field_order_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Telephone.field_order)
}
inline void Telephone::add_field_order(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.sparrowhawk.Telephone.field_order)
}
inline void Telephone::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.sparrowhawk.Telephone.field_order)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Telephone::field_order() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.Telephone.field_order)
  return field_order_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Telephone::mutable_field_order() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.Telephone.field_order)
  return &field_order_;
}

// -------------------------------------------------------------------

// Electronic

// optional string protocol = 1;
inline bool Electronic::_internal_has_protocol() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Electronic::has_protocol() const {
  return _internal_has_protocol();
}
inline void Electronic::clear_protocol() {
  protocol_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Electronic::protocol() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Electronic.protocol)
  return _internal_protocol();
}
inline void Electronic::set_protocol(const std::string& value) {
  _internal_set_protocol(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.protocol)
}
inline std::string* Electronic::mutable_protocol() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Electronic.protocol)
  return _internal_mutable_protocol();
}
inline const std::string& Electronic::_internal_protocol() const {
  return protocol_.Get();
}
inline void Electronic::_internal_set_protocol(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  protocol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Electronic::set_protocol(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  protocol_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Electronic.protocol)
}
inline void Electronic::set_protocol(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  protocol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Electronic.protocol)
}
inline void Electronic::set_protocol(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  protocol_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Electronic.protocol)
}
inline std::string* Electronic::_internal_mutable_protocol() {
  _has_bits_[0] |= 0x00000001u;
  return protocol_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Electronic::release_protocol() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Electronic.protocol)
  if (!_internal_has_protocol()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return protocol_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Electronic::set_allocated_protocol(std::string* protocol) {
  if (protocol != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  protocol_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), protocol,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Electronic.protocol)
}

// optional string username = 2;
inline bool Electronic::_internal_has_username() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Electronic::has_username() const {
  return _internal_has_username();
}
inline void Electronic::clear_username() {
  username_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Electronic::username() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Electronic.username)
  return _internal_username();
}
inline void Electronic::set_username(const std::string& value) {
  _internal_set_username(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.username)
}
inline std::string* Electronic::mutable_username() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Electronic.username)
  return _internal_mutable_username();
}
inline const std::string& Electronic::_internal_username() const {
  return username_.Get();
}
inline void Electronic::_internal_set_username(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Electronic::set_username(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  username_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Electronic.username)
}
inline void Electronic::set_username(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Electronic.username)
}
inline void Electronic::set_username(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Electronic.username)
}
inline std::string* Electronic::_internal_mutable_username() {
  _has_bits_[0] |= 0x00000002u;
  return username_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Electronic::release_username() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Electronic.username)
  if (!_internal_has_username()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return username_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Electronic::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  username_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), username,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Electronic.username)
}

// optional string password = 3;
inline bool Electronic::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Electronic::has_password() const {
  return _internal_has_password();
}
inline void Electronic::clear_password() {
  password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Electronic::password() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Electronic.password)
  return _internal_password();
}
inline void Electronic::set_password(const std::string& value) {
  _internal_set_password(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.password)
}
inline std::string* Electronic::mutable_password() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Electronic.password)
  return _internal_mutable_password();
}
inline const std::string& Electronic::_internal_password() const {
  return password_.Get();
}
inline void Electronic::_internal_set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Electronic::set_password(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  password_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Electronic.password)
}
inline void Electronic::set_password(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Electronic.password)
}
inline void Electronic::set_password(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Electronic.password)
}
inline std::string* Electronic::_internal_mutable_password() {
  _has_bits_[0] |= 0x00000004u;
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Electronic::release_password() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Electronic.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Electronic::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Electronic.password)
}

// optional string domain = 4;
inline bool Electronic::_internal_has_domain() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool Electronic::has_domain() const {
  return _internal_has_domain();
}
inline void Electronic::clear_domain() {
  domain_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& Electronic::domain() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Electronic.domain)
  return _internal_domain();
}
inline void Electronic::set_domain(const std::string& value) {
  _internal_set_domain(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.domain)
}
inline std::string* Electronic::mutable_domain() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Electronic.domain)
  return _internal_mutable_domain();
}
inline const std::string& Electronic::_internal_domain() const {
  return domain_.Get();
}
inline void Electronic::_internal_set_domain(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Electronic::set_domain(std::string&& value) {
  _has_bits_[0] |= 0x00000008u;
  domain_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Electronic.domain)
}
inline void Electronic::set_domain(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000008u;
  domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Electronic.domain)
}
inline void Electronic::set_domain(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000008u;
  domain_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Electronic.domain)
}
inline std::string* Electronic::_internal_mutable_domain() {
  _has_bits_[0] |= 0x00000008u;
  return domain_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Electronic::release_domain() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Electronic.domain)
  if (!_internal_has_domain()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  return domain_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Electronic::set_allocated_domain(std::string* domain) {
  if (domain != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  domain_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), domain,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Electronic.domain)
}

// optional int32 port = 5;
inline bool Electronic::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool Electronic::has_port() const {
  return _internal_has_port();
}
inline void Electronic::clear_port() {
  port_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Electronic::_internal_port() const {
  return port_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Electronic::port() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Electronic.port)
  return _internal_port();
}
inline void Electronic::_internal_set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _has_bits_[0] |= 0x00000200u;
  port_ = value;
}
inline void Electronic::set_port(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.port)
}

// optional string path = 6;
inline bool Electronic::_internal_has_path() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool Electronic::has_path() const {
  return _internal_has_path();
}
inline void Electronic::clear_path() {
  path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& Electronic::path() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Electronic.path)
  return _internal_path();
}
inline void Electronic::set_path(const std::string& value) {
  _internal_set_path(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.path)
}
inline std::string* Electronic::mutable_path() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Electronic.path)
  return _internal_mutable_path();
}
inline const std::string& Electronic::_internal_path() const {
  return path_.Get();
}
inline void Electronic::_internal_set_path(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Electronic::set_path(std::string&& value) {
  _has_bits_[0] |= 0x00000010u;
  path_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Electronic.path)
}
inline void Electronic::set_path(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000010u;
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Electronic.path)
}
inline void Electronic::set_path(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000010u;
  path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Electronic.path)
}
inline std::string* Electronic::_internal_mutable_path() {
  _has_bits_[0] |= 0x00000010u;
  return path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Electronic::release_path() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Electronic.path)
  if (!_internal_has_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  return path_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Electronic::set_allocated_path(std::string* path) {
  if (path != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), path,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Electronic.path)
}

// optional string query_string = 7;
inline bool Electronic::_internal_has_query_string() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool Electronic::has_query_string() const {
  return _internal_has_query_string();
}
inline void Electronic::clear_query_string() {
  query_string_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& Electronic::query_string() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Electronic.query_string)
  return _internal_query_string();
}
inline void Electronic::set_query_string(const std::string& value) {
  _internal_set_query_string(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.query_string)
}
inline std::string* Electronic::mutable_query_string() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Electronic.query_string)
  return _internal_mutable_query_string();
}
inline const std::string& Electronic::_internal_query_string() const {
  return query_string_.Get();
}
inline void Electronic::_internal_set_query_string(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  query_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Electronic::set_query_string(std::string&& value) {
  _has_bits_[0] |= 0x00000020u;
  query_string_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Electronic.query_string)
}
inline void Electronic::set_query_string(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000020u;
  query_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Electronic.query_string)
}
inline void Electronic::set_query_string(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000020u;
  query_string_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Electronic.query_string)
}
inline std::string* Electronic::_internal_mutable_query_string() {
  _has_bits_[0] |= 0x00000020u;
  return query_string_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Electronic::release_query_string() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Electronic.query_string)
  if (!_internal_has_query_string()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  return query_string_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Electronic::set_allocated_query_string(std::string* query_string) {
  if (query_string != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  query_string_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), query_string,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Electronic.query_string)
}

// optional string fragment_id = 8;
inline bool Electronic::_internal_has_fragment_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool Electronic::has_fragment_id() const {
  return _internal_has_fragment_id();
}
inline void Electronic::clear_fragment_id() {
  fragment_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& Electronic::fragment_id() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Electronic.fragment_id)
  return _internal_fragment_id();
}
inline void Electronic::set_fragment_id(const std::string& value) {
  _internal_set_fragment_id(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.fragment_id)
}
inline std::string* Electronic::mutable_fragment_id() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Electronic.fragment_id)
  return _internal_mutable_fragment_id();
}
inline const std::string& Electronic::_internal_fragment_id() const {
  return fragment_id_.Get();
}
inline void Electronic::_internal_set_fragment_id(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  fragment_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Electronic::set_fragment_id(std::string&& value) {
  _has_bits_[0] |= 0x00000040u;
  fragment_id_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Electronic.fragment_id)
}
inline void Electronic::set_fragment_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000040u;
  fragment_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Electronic.fragment_id)
}
inline void Electronic::set_fragment_id(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000040u;
  fragment_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Electronic.fragment_id)
}
inline std::string* Electronic::_internal_mutable_fragment_id() {
  _has_bits_[0] |= 0x00000040u;
  return fragment_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Electronic::release_fragment_id() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Electronic.fragment_id)
  if (!_internal_has_fragment_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  return fragment_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Electronic::set_allocated_fragment_id(std::string* fragment_id) {
  if (fragment_id != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  fragment_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fragment_id,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Electronic.fragment_id)
}

// optional string morphosyntactic_features = 9;
inline bool Electronic::_internal_has_morphosyntactic_features() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool Electronic::has_morphosyntactic_features() const {
  return _internal_has_morphosyntactic_features();
}
inline void Electronic::clear_morphosyntactic_features() {
  morphosyntactic_features_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& Electronic::morphosyntactic_features() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Electronic.morphosyntactic_features)
  return _internal_morphosyntactic_features();
}
inline void Electronic::set_morphosyntactic_features(const std::string& value) {
  _internal_set_morphosyntactic_features(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.morphosyntactic_features)
}
inline std::string* Electronic::mutable_morphosyntactic_features() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Electronic.morphosyntactic_features)
  return _internal_mutable_morphosyntactic_features();
}
inline const std::string& Electronic::_internal_morphosyntactic_features() const {
  return morphosyntactic_features_.Get();
}
inline void Electronic::_internal_set_morphosyntactic_features(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Electronic::set_morphosyntactic_features(std::string&& value) {
  _has_bits_[0] |= 0x00000080u;
  morphosyntactic_features_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Electronic.morphosyntactic_features)
}
inline void Electronic::set_morphosyntactic_features(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000080u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Electronic.morphosyntactic_features)
}
inline void Electronic::set_morphosyntactic_features(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000080u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Electronic.morphosyntactic_features)
}
inline std::string* Electronic::_internal_mutable_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000080u;
  return morphosyntactic_features_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Electronic::release_morphosyntactic_features() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Electronic.morphosyntactic_features)
  if (!_internal_has_morphosyntactic_features()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  return morphosyntactic_features_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Electronic::set_allocated_morphosyntactic_features(std::string* morphosyntactic_features) {
  if (morphosyntactic_features != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  morphosyntactic_features_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), morphosyntactic_features,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Electronic.morphosyntactic_features)
}

// optional bool preserve_order = 10;
inline bool Electronic::_internal_has_preserve_order() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool Electronic::has_preserve_order() const {
  return _internal_has_preserve_order();
}
inline void Electronic::clear_preserve_order() {
  preserve_order_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool Electronic::_internal_preserve_order() const {
  return preserve_order_;
}
inline bool Electronic::preserve_order() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Electronic.preserve_order)
  return _internal_preserve_order();
}
inline void Electronic::_internal_set_preserve_order(bool value) {
  _has_bits_[0] |= 0x00000400u;
  preserve_order_ = value;
}
inline void Electronic::set_preserve_order(bool value) {
  _internal_set_preserve_order(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.preserve_order)
}

// optional string code_switch = 11;
inline bool Electronic::_internal_has_code_switch() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool Electronic::has_code_switch() const {
  return _internal_has_code_switch();
}
inline void Electronic::clear_code_switch() {
  code_switch_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& Electronic::code_switch() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Electronic.code_switch)
  return _internal_code_switch();
}
inline void Electronic::set_code_switch(const std::string& value) {
  _internal_set_code_switch(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.code_switch)
}
inline std::string* Electronic::mutable_code_switch() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Electronic.code_switch)
  return _internal_mutable_code_switch();
}
inline const std::string& Electronic::_internal_code_switch() const {
  return code_switch_.Get();
}
inline void Electronic::_internal_set_code_switch(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Electronic::set_code_switch(std::string&& value) {
  _has_bits_[0] |= 0x00000100u;
  code_switch_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Electronic.code_switch)
}
inline void Electronic::set_code_switch(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000100u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Electronic.code_switch)
}
inline void Electronic::set_code_switch(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000100u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Electronic.code_switch)
}
inline std::string* Electronic::_internal_mutable_code_switch() {
  _has_bits_[0] |= 0x00000100u;
  return code_switch_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Electronic::release_code_switch() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Electronic.code_switch)
  if (!_internal_has_code_switch()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  return code_switch_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Electronic::set_allocated_code_switch(std::string* code_switch) {
  if (code_switch != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  code_switch_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code_switch,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Electronic.code_switch)
}

// repeated string field_order = 12;
inline int Electronic::_internal_field_order_size() const {
  return field_order_.size();
}
inline int Electronic::field_order_size() const {
  return _internal_field_order_size();
}
inline void Electronic::clear_field_order() {
  field_order_.Clear();
}
inline std::string* Electronic::add_field_order() {
  // @@protoc_insertion_point(field_add_mutable:speech.sparrowhawk.Electronic.field_order)
  return _internal_add_field_order();
}
inline const std::string& Electronic::_internal_field_order(int index) const {
  return field_order_.Get(index);
}
inline const std::string& Electronic::field_order(int index) const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Electronic.field_order)
  return _internal_field_order(index);
}
inline std::string* Electronic::mutable_field_order(int index) {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Electronic.field_order)
  return field_order_.Mutable(index);
}
inline void Electronic::set_field_order(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.field_order)
  field_order_.Mutable(index)->assign(value);
}
inline void Electronic::set_field_order(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Electronic.field_order)
  field_order_.Mutable(index)->assign(std::move(value));
}
inline void Electronic::set_field_order(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  field_order_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Electronic.field_order)
}
inline void Electronic::set_field_order(int index, const char* value, size_t size) {
  field_order_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Electronic.field_order)
}
inline std::string* Electronic::_internal_add_field_order() {
  return field_order_.Add();
}
inline void Electronic::add_field_order(const std::string& value) {
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Electronic.field_order)
}
inline void Electronic::add_field_order(std::string&& value) {
  field_order_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:speech.sparrowhawk.Electronic.field_order)
}
inline void Electronic::add_field_order(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  field_order_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:speech.sparrowhawk.Electronic.field_order)
}
inline void Electronic::add_field_order(const char* value, size_t size) {
  field_order_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:speech.sparrowhawk.Electronic.field_order)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Electronic::field_order() const {
  // @@protoc_insertion_point(field_list:speech.sparrowhawk.Electronic.field_order)
  return field_order_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Electronic::mutable_field_order() {
  // @@protoc_insertion_point(field_mutable_list:speech.sparrowhawk.Electronic.field_order)
  return &field_order_;
}

// -------------------------------------------------------------------

// Connector

// optional string type = 1;
inline bool Connector::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Connector::has_type() const {
  return _internal_has_type();
}
inline void Connector::clear_type() {
  type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Connector::type() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Connector.type)
  return _internal_type();
}
inline void Connector::set_type(const std::string& value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Connector.type)
}
inline std::string* Connector::mutable_type() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Connector.type)
  return _internal_mutable_type();
}
inline const std::string& Connector::_internal_type() const {
  return type_.Get();
}
inline void Connector::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Connector::set_type(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  type_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Connector.type)
}
inline void Connector::set_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Connector.type)
}
inline void Connector::set_type(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Connector.type)
}
inline std::string* Connector::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000001u;
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Connector::release_type() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Connector.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Connector::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Connector.type)
}

// optional string morphosyntactic_features = 2;
inline bool Connector::_internal_has_morphosyntactic_features() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Connector::has_morphosyntactic_features() const {
  return _internal_has_morphosyntactic_features();
}
inline void Connector::clear_morphosyntactic_features() {
  morphosyntactic_features_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Connector::morphosyntactic_features() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Connector.morphosyntactic_features)
  return _internal_morphosyntactic_features();
}
inline void Connector::set_morphosyntactic_features(const std::string& value) {
  _internal_set_morphosyntactic_features(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Connector.morphosyntactic_features)
}
inline std::string* Connector::mutable_morphosyntactic_features() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Connector.morphosyntactic_features)
  return _internal_mutable_morphosyntactic_features();
}
inline const std::string& Connector::_internal_morphosyntactic_features() const {
  return morphosyntactic_features_.Get();
}
inline void Connector::_internal_set_morphosyntactic_features(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Connector::set_morphosyntactic_features(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  morphosyntactic_features_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Connector.morphosyntactic_features)
}
inline void Connector::set_morphosyntactic_features(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Connector.morphosyntactic_features)
}
inline void Connector::set_morphosyntactic_features(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Connector.morphosyntactic_features)
}
inline std::string* Connector::_internal_mutable_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000002u;
  return morphosyntactic_features_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Connector::release_morphosyntactic_features() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Connector.morphosyntactic_features)
  if (!_internal_has_morphosyntactic_features()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return morphosyntactic_features_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Connector::set_allocated_morphosyntactic_features(std::string* morphosyntactic_features) {
  if (morphosyntactic_features != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  morphosyntactic_features_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), morphosyntactic_features,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Connector.morphosyntactic_features)
}

// optional string code_switch = 3;
inline bool Connector::_internal_has_code_switch() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Connector::has_code_switch() const {
  return _internal_has_code_switch();
}
inline void Connector::clear_code_switch() {
  code_switch_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Connector::code_switch() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Connector.code_switch)
  return _internal_code_switch();
}
inline void Connector::set_code_switch(const std::string& value) {
  _internal_set_code_switch(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Connector.code_switch)
}
inline std::string* Connector::mutable_code_switch() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Connector.code_switch)
  return _internal_mutable_code_switch();
}
inline const std::string& Connector::_internal_code_switch() const {
  return code_switch_.Get();
}
inline void Connector::_internal_set_code_switch(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Connector::set_code_switch(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  code_switch_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Connector.code_switch)
}
inline void Connector::set_code_switch(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Connector.code_switch)
}
inline void Connector::set_code_switch(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Connector.code_switch)
}
inline std::string* Connector::_internal_mutable_code_switch() {
  _has_bits_[0] |= 0x00000004u;
  return code_switch_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Connector::release_code_switch() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Connector.code_switch)
  if (!_internal_has_code_switch()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return code_switch_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Connector::set_allocated_code_switch(std::string* code_switch) {
  if (code_switch != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  code_switch_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code_switch,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Connector.code_switch)
}

// -------------------------------------------------------------------

// Abbreviation

// required string text = 1;
inline bool Abbreviation::_internal_has_text() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Abbreviation::has_text() const {
  return _internal_has_text();
}
inline void Abbreviation::clear_text() {
  text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Abbreviation::text() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Abbreviation.text)
  return _internal_text();
}
inline void Abbreviation::set_text(const std::string& value) {
  _internal_set_text(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Abbreviation.text)
}
inline std::string* Abbreviation::mutable_text() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Abbreviation.text)
  return _internal_mutable_text();
}
inline const std::string& Abbreviation::_internal_text() const {
  return text_.Get();
}
inline void Abbreviation::_internal_set_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Abbreviation::set_text(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Abbreviation.text)
}
inline void Abbreviation::set_text(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Abbreviation.text)
}
inline void Abbreviation::set_text(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000001u;
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Abbreviation.text)
}
inline std::string* Abbreviation::_internal_mutable_text() {
  _has_bits_[0] |= 0x00000001u;
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Abbreviation::release_text() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Abbreviation.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return text_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Abbreviation::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Abbreviation.text)
}

// optional string morphosyntactic_features = 2;
inline bool Abbreviation::_internal_has_morphosyntactic_features() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Abbreviation::has_morphosyntactic_features() const {
  return _internal_has_morphosyntactic_features();
}
inline void Abbreviation::clear_morphosyntactic_features() {
  morphosyntactic_features_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Abbreviation::morphosyntactic_features() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Abbreviation.morphosyntactic_features)
  return _internal_morphosyntactic_features();
}
inline void Abbreviation::set_morphosyntactic_features(const std::string& value) {
  _internal_set_morphosyntactic_features(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Abbreviation.morphosyntactic_features)
}
inline std::string* Abbreviation::mutable_morphosyntactic_features() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Abbreviation.morphosyntactic_features)
  return _internal_mutable_morphosyntactic_features();
}
inline const std::string& Abbreviation::_internal_morphosyntactic_features() const {
  return morphosyntactic_features_.Get();
}
inline void Abbreviation::_internal_set_morphosyntactic_features(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Abbreviation::set_morphosyntactic_features(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  morphosyntactic_features_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Abbreviation.morphosyntactic_features)
}
inline void Abbreviation::set_morphosyntactic_features(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Abbreviation.morphosyntactic_features)
}
inline void Abbreviation::set_morphosyntactic_features(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000002u;
  morphosyntactic_features_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Abbreviation.morphosyntactic_features)
}
inline std::string* Abbreviation::_internal_mutable_morphosyntactic_features() {
  _has_bits_[0] |= 0x00000002u;
  return morphosyntactic_features_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Abbreviation::release_morphosyntactic_features() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Abbreviation.morphosyntactic_features)
  if (!_internal_has_morphosyntactic_features()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return morphosyntactic_features_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Abbreviation::set_allocated_morphosyntactic_features(std::string* morphosyntactic_features) {
  if (morphosyntactic_features != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  morphosyntactic_features_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), morphosyntactic_features,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Abbreviation.morphosyntactic_features)
}

// optional string code_switch = 3;
inline bool Abbreviation::_internal_has_code_switch() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool Abbreviation::has_code_switch() const {
  return _internal_has_code_switch();
}
inline void Abbreviation::clear_code_switch() {
  code_switch_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& Abbreviation::code_switch() const {
  // @@protoc_insertion_point(field_get:speech.sparrowhawk.Abbreviation.code_switch)
  return _internal_code_switch();
}
inline void Abbreviation::set_code_switch(const std::string& value) {
  _internal_set_code_switch(value);
  // @@protoc_insertion_point(field_set:speech.sparrowhawk.Abbreviation.code_switch)
}
inline std::string* Abbreviation::mutable_code_switch() {
  // @@protoc_insertion_point(field_mutable:speech.sparrowhawk.Abbreviation.code_switch)
  return _internal_mutable_code_switch();
}
inline const std::string& Abbreviation::_internal_code_switch() const {
  return code_switch_.Get();
}
inline void Abbreviation::_internal_set_code_switch(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArena());
}
inline void Abbreviation::set_code_switch(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  code_switch_.Set(
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::move(value), GetArena());
  // @@protoc_insertion_point(field_set_rvalue:speech.sparrowhawk.Abbreviation.code_switch)
}
inline void Abbreviation::set_code_switch(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(value), GetArena());
  // @@protoc_insertion_point(field_set_char:speech.sparrowhawk.Abbreviation.code_switch)
}
inline void Abbreviation::set_code_switch(const char* value,
    size_t size) {
  _has_bits_[0] |= 0x00000004u;
  code_switch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, ::std::string(
      reinterpret_cast<const char*>(value), size), GetArena());
  // @@protoc_insertion_point(field_set_pointer:speech.sparrowhawk.Abbreviation.code_switch)
}
inline std::string* Abbreviation::_internal_mutable_code_switch() {
  _has_bits_[0] |= 0x00000004u;
  return code_switch_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArena());
}
inline std::string* Abbreviation::release_code_switch() {
  // @@protoc_insertion_point(field_release:speech.sparrowhawk.Abbreviation.code_switch)
  if (!_internal_has_code_switch()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return code_switch_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
}
inline void Abbreviation::set_allocated_code_switch(std::string* code_switch) {
  if (code_switch != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  code_switch_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code_switch,
      GetArena());
  // @@protoc_insertion_point(field_set_allocated:speech.sparrowhawk.Abbreviation.code_switch)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace sparrowhawk
}  // namespace speech

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_semiotic_5fclasses_2eproto
